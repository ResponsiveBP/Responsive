{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/app.js","webpack:///./src/js/base.js","webpack:///./src/js/carousel.js","webpack:///./src/js/conditional.js","webpack:///./src/js/core.js","webpack:///./src/js/dismiss.js","webpack:///./src/js/dropdown.js","webpack:///./src/js/dum.js","webpack:///./src/js/modal.js","webpack:///./src/js/swiper.js","webpack:///./src/js/tablelist.js","webpack:///./src/js/tabs.js","webpack:///./src/sass/app.scss"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8B;AACE;AACN;AACU;AACF;AACM;AACN;AACN;;;;;;;;;;;;;;ACP5B;AAAA;AAAA;AAAsB;AACM;;AAE5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;;AAEA,CAAC,EAAE,4CAAE,EAAE,6CAAO;;AAEC,sEAAO,E;;;;;;;;;;;;AChCtB;AAAA;AAAA;AAAA;AAAA;AAAuB;AACO;AACD;AACA;;AAE7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA4B,UAAU;AACtC,0BAA0B,UAAU;;AAEpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,yCAAyC;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,uBAAuB,gDAAgD;AACvE;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,gBAAgB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,mCAAmC;;AAEjE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,uBAAuB;;AAE5D;AACA,mCAAmC,8BAA8B;AACjE,WAAW;AACX,qCAAqC,sBAAsB;;AAE3D;AACA,mCAAmC,6BAA6B;AAChE;AACA,SAAS;AACT,mCAAmC,uCAAuC;AAC1E;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,2BAA2B,YAAY,IAAI;AAC5E;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,oCAAoC;AAC9E;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,0CAA0C,oCAAoC;AAC9E;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,gCAAgC,uCAAuC;;AAEvE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,8BAA8B,qCAAqC;;AAEnE;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,mCAAmC;AAClE;AACA;AACA;;AAEA;AACA;AACA,CAAC,EAAE,4CAAE,EAAE,+CAAM,EAAE,6CAAO,EAAE,6CAAO;;AAEhB,0EAAW,EAAC;;;;;;;;;;;;;AChjB3B;AAAA;AAAA;AAAA;AAAsB;AACM;AACA;;AAE5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,wDAAwD,0EAA0E;AAClI;AACA;;AAEA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,sEAAsE,WAAW,YAAY;AAC7F;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA,CAAC,EAAE,4CAAE,EAAE,6CAAO,EAAE,6CAAO;;AAER,6EAAc,E;;;;;;;;;;;;ACtG7B;AAAA;AAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;;AAEA,oBAAoB,GAAG;AACvB;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,iDAAiD,iBAAiB;AAClE;;AAEA;AACA;AACA,eAAe,IAAI;AACnB,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,+BAA+B,UAAU,GAAG,mBAAmB;AAC/D,wBAAwB;AACxB,iBAAiB,UAAU;AAC3B;AACA;;AAEA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,IAAI;AACnB,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA,yBAAyB,UAAU;AACnC,qCAAqC,UAAU;AAC/C;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET,8BAA8B,aAAa;AAC3C;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,IAAI;AACnB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,CAAC,EAAE,4CAAE;;AAEU,sEAAO,EAAC;;;;;;;;;;;;;AC1bvB;AAAA;AAAA;AAAA;AAAuB;AACM;AACA;;AAE7B;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,iBAAiB;AACjD;AACA,iCAAiC,gBAAgB;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC,EAAE,4CAAE,EAAE,6CAAO,EAAE,6CAAO;;AAER,yEAAU,EAAC;;;;;;;;;;;;;AChE1B;AAAA;AAAA;AAAA;AAAuB;AACM;AACA;;AAE7B;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA,0BAA0B,UAAU;AACpC,4BAA4B,UAAU;AACtC,0BAA0B,UAAU;AACpC,8BAA8B,UAAU;;AAExC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,iCAAiC,eAAe;AAChD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,+BAA+B;;AAEnE;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA,qCAAqC,eAAe;AACpD;;AAEA;AACA,2BAA2B,mDAAmD;;AAE9E;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA,gCAAgC,iBAAiB;;AAEjD;AACA;AACA,kCAAkC,sBAAsB;AACxD,iCAAiC,uBAAuB;AACxD;AACA;;AAEA;AACA,kCAAkC,iBAAiB;AACnD;AACA;;AAEA,gCAAgC,0BAA0B;AAC1D;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC,oBAAoB;AACtD;AACA;;AAEA;AACA;AACA,OAAO;AACP,gCAAgC,iBAAiB;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC,EAAE,4CAAE,EAAE,6CAAO,EAAE,6CAAO;;AAER,0EAAW,EAAC;;;;;;;;;;;;;AC3P3B;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,0DAA0D;;AAE1D;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,UAAU;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2BAA2B,6CAA6C;AACvF,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO,oCAAoC;AAC1D,eAAe,2BAA2B,sCAAsC;AAChF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO,oCAAoC;AAC1D,eAAe,2CAA2C,iEAAiE;AAC3H,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO,6CAA6C;AACnE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO,6CAA6C;AACnE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C,eAAe,OAAO,6CAA6C;AACnE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,mBAAmB,2CAA2C;AAC7E,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,4BAA4B;AAC3C,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,eAAe,4BAA4B;AAC3C,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA,eAAe,4BAA4B;AAC3C,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,OAAO;AACP;;AAEA;AACA;AACA,eAAe,4BAA4B;AAC3C,eAAe,kBAAkB;AACjC,eAAe,mBAAmB,2CAA2C;AAC7E,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C,eAAe,kBAAkB;AACjC,eAAe,mBAAmB,kCAAkC;AACpE,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,4BAA4B;AAC3C,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,CAAC;;AAEc,iEAAE,EAAC;;;;;;;;;;;;;ACtlBlB;AAAA;AAAA;AAAA;AAAsB;AACM;AACA;;AAE5B;;AAEA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,mCAAmC,aAAa;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,QAAQ;AAC1D,2FAA2F,sBAAsB;AACjH,kGAAkG,eAAe;AACjH,6EAA6E,cAAc;AAC3F,6FAA6F,cAAc;;AAE3G;AACA;AACA,8DAA8D,aAAa,IAAI,mBAAmB;AAClG;;AAEA;;AAEA;AACA;AACA,6DAA6D,YAAY,IAAI,yBAAyB;AACtG;;AAEA;AACA,8DAA8D,0CAA0C;AACxG;;AAEA,0CAA0C,uBAAuB,mBAAmB,GAAG,kBAAkB,GAAG;AAC5G;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,QAAQ;;AAEvC;AACA,wCAAwC,eAAe;AACvD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,+BAA+B,QAAQ;;AAEvC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gCAAgC,QAAQ;;AAExC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,gCAAgC,QAAQ;;AAExC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC,EAAE,4CAAE,EAAE,6CAAO,EAAE,6CAAO;;AAER,uEAAQ,E;;;;;;;;;;;;AChWvB;AAAA;AAAsB;;AAEtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,GAAG;AACpC,+BAA+B,GAAG;AAClC,6BAA6B,GAAG;AAChC,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,gCAAgC,kCAAkC;AAClE,aAAa;AACb;;AAEA;;AAEA,0BAA0B;AAC1B;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oFAAoF,SAAS,eAAe,EAAE;AAC9G;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2EAA2E,yDAAyD;AACpI;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yEAAyE,eAAe;AACxF;AACA;;AAEA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,6CAA6C,UAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC,EAAE,4CAAE;;AAEU,qE;;;;;;;;;;;;ACnOf;AAAA;AAAA;AAAA;AAAsB;AACM;AACA;;AAE5B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sCAAsC,sBAAsB;;AAE5D;AACA;AACA;AACA;;AAEA;AACA;AACA,2DAA2D,sDAAsD;AACjH;AACA,uCAAuC,qBAAqB;;AAE5D;AACA;AACA;AACA;AACA;AACA,2DAA2D,sDAAsD;;AAEjH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,sFAAsF;;AAEzH;AACA;AACA;AACA;;AAEA,uCAAuC,sFAAsF;AAC7H;AACA,iBAAiB;AACjB,aAAa;;AAEb,oCAAoC,uCAAuC;;AAE3E;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC,EAAE,4CAAE,EAAE,6CAAO,EAAE,6CAAO;;AAER,2EAAY,E;;;;;;;;;;;;AChF3B;AAAA;AAAA;AAAA;AAAsB;AACM;AACA;;AAE5B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sCAAsC,oBAAoB;AAC1D;;AAEA,+BAA+B,yBAAyB;;AAExD;AACA;;AAEA;AACA;AACA,6BAA6B,GAAG,GAAG,EAAE;AACrC,wCAAwC,GAAG,GAAG,EAAE;AAChD;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA,6BAA6B,GAAG,GAAG,EAAE;AACrC,0CAA0C,GAAG,GAAG,EAAE;AAClD;AACA,iBAAiB;AACjB,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,yDAAyD,yBAAyB;AAClF;AACA,+BAA+B,wBAAwB,EAAE;AACzD,aAAa;;AAEb;AACA;AACA,kCAAkC,gBAAgB;AAClD;;AAEA;AACA;;AAEA,iCAAiC,iBAAiB;AAClD;;AAEA;AACA;AACA;AACA,uDAAuD,0BAA0B;AACjF;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC,EAAE,4CAAE,EAAE,6CAAO,EAAE,6CAAO;;AAER,sEAAO,E;;;;;;;;;;;AC7JtB,uC","file":"responsive.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import swiper from \"./swiper\";\r\nimport dismiss from \"./dismiss\";\r\nimport tabs from \"./tabs\";\r\nimport tablelist from \"./tablelist\";\r\nimport dropdown from \"./dropdown\";\r\nimport conditional from \"./conditional\";\r\nimport carousel from \"./carousel\";\r\nimport modal from \"./modal\";\r\n\r\nexport { swiper, dismiss, tabs, tablelist, dropdown, conditional, carousel, modal }","import $d from \"./dum\"\r\nimport RbpCore from \"./core\"\r\n\r\nconst RbpBase = (($d, core) => {\r\n\r\n    class RbpBase {\r\n        constructor(element, defaults, options, prefix) {\r\n            this.element = element;\r\n            this.element.id = element.id || core.uid();\r\n            this.options = this.extend(defaults, options || this.dataOptions(prefix));\r\n            this.rtl = core.isRtl(this.element);\r\n        }\r\n\r\n        extend(defaults, options) {\r\n            return Object.assign({}, defaults, options)\r\n        }\r\n\r\n        dataOptions(prefix) {\r\n            let result = {};\r\n            Object.entries(core.data(this.element).attr).forEach(d => {\r\n                // eslint-disable-next-line prefer-destructuring\r\n                result[core.camelCase(d[0].slice(prefix && prefix.length || 0))] = d[1];\r\n            });\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    return RbpBase;\r\n\r\n})($d, RbpCore);\r\n\r\nexport default RbpBase;","import $d from \"./dum\";\r\nimport Swiper from \"./swiper\";\r\nimport RbpBase from \"./base\";\r\nimport RbpCore from \"./core\";\r\n\r\nconst RbpCarousel = (($d, swiper, core, base, w, d) => {\r\n  const rhint = /\\((\\w+)\\|(\\w+)\\)/;\r\n\r\n  const cactive = \"carousel-active\",\r\n    citems = \"figure, .slide\";\r\n\r\n  const defaults = {\r\n    interval: 0, // Better for a11y\r\n    mode: \"slide\",\r\n    pause: \"hover\",\r\n    wrap: true,\r\n    keyboard: true,\r\n    touch: true,\r\n    lazyImages: true,\r\n    lazyOnDemand: true,\r\n    nextTrigger: null,\r\n    nextHint: \"Next: (Left|Right) Arrow\",\r\n    prevTrigger: null,\r\n    prevHint: \"Previous: (Right|Left) Arrow\",\r\n    indicators: null\r\n  };\r\n\r\n  class RbpCarousel extends base {\r\n    constructor(element, options) {\r\n      super(element, defaults, options, \"carousel\");\r\n\r\n      const namespace = \".rbp.carousel\";\r\n      this.eslide = `slide${namespace}`;\r\n      this.eslid = `slid${namespace}`;\r\n\r\n      this.paused = null;\r\n      this.sliding = null;\r\n      this.keyboardTriggered = null;\r\n      this.translationDuration = null;\r\n\r\n      this.nextHint = this.options.nextHint.replace(\r\n        rhint,\r\n        this.rtl ? \"$1\" : \"$2\"\r\n      );\r\n      this.prevHint = this.options.prevHint.replace(\r\n        rhint,\r\n        this.rtl ? \"$1\" : \"$2\"\r\n      );\r\n\r\n      this.nextTrigger = this.options.nextTrigger\r\n        ? $d.query(this.options.nextTrigger)\r\n        : $d.children(this.element, \"button.forward\")[0];\r\n\r\n      this.prevTrigger = this.options.prevTrigger\r\n        ? $d.query(this.options.prevTrigger)\r\n        : $d.children(this.element, \"button:not(.forward)\")[0];\r\n\r\n      this.indicators = this.options.indicators\r\n        ? $d.query(this.options.indicators)\r\n        : $d.children($d.children(this.element, \"ol\")[0], \"li\");\r\n\r\n      this.options.mode === \"fade\" &&\r\n        $d.addClass(this.element, \"carousel-fade\");\r\n      this.items = $d.children(this.element, citems);\r\n      this.interval = parseInt(this.options.interval, 10);\r\n\r\n      const activeIndex = this.activeIndex();\r\n\r\n      // Hide the previous button if no wrapping.\r\n      const hidden = { \"aria-hidden\": true, hidden: true };\r\n      if (!this.options.wrap) {\r\n        if (activeIndex === 0) {\r\n          $d.setAttr(this.prevTrigger, hidden);\r\n        }\r\n      }\r\n\r\n      // Hide both if one item.\r\n      if (this.items.length === 1) {\r\n        $d.setAttr(this.prevTrigger, hidden);\r\n        $d.setAttr(this.nextTrigger, hidden);\r\n      }\r\n\r\n      // Add a11y features.\r\n      $d.setAttr(this.element, { role: \"listbox\", \"aria-live\": \"polite\" });\r\n\r\n      // Slides\r\n      this.items.forEach((p, i) => {\r\n        const active = i === activeIndex;\r\n        $d.setAttr(p, {\r\n          role: \"option\",\r\n          \"aria-selected\": active,\r\n          tabindex: active ? 0 : -1\r\n        });\r\n      });\r\n\r\n      // Controls.\r\n      [this.nextTrigger, this.prevTrigger].forEach(t => {\r\n        if (t === undefined) {\r\n          return;\r\n        }\r\n        $d.setAttr(t, { tabindex: 0, \"aria-controls\": this.element.id });\r\n        if (!t.tagName === \"BUTTON\") {\r\n          $d.setAttr(t, { role: \"button\" });\r\n        }\r\n        if (!$d.query(\".vhidden\", t)) {\r\n          let span = $d.create(\"span\");\r\n          $d.addClass(span, \"vhidden\");\r\n          span.innerHTML =\r\n            t === this.nextTrigger ? this.nextHint : this.prevHint;\r\n          $d.append(t, span);\r\n        }\r\n      });\r\n\r\n      // Indicators.\r\n      $d.setAttr(this.indicators, {\r\n        role: \"button\",\r\n        \"aria-controls\": this.element.id\r\n      });\r\n      this.indicators.forEach((i, idx) => {\r\n        idx === activeIndex && $d.addClass(i, \"active\");\r\n      });\r\n\r\n      // Bind events\r\n      if (this.options.lazyImages && !this.options.lazyOnDemand) {\r\n        $d.on(\r\n          w,\r\n          \"load\",\r\n          null,\r\n          this.lazyimages.bind(this, this.items[activeIndex])\r\n        );\r\n      }\r\n\r\n      if (this.interval > 0 && this.options.pause === \"hover\") {\r\n        // Bind the mouse enter/leave events.\r\n        if (!core.support.touchEvents && !core.support.pointerEvents) {\r\n          $d.on(this.element, \"mouseenter\", null, this.pause.bind(this));\r\n          $d.on(this.element, \"mouseleave\", null, this.cycle.bind(this));\r\n        }\r\n      }\r\n\r\n      if (this.options.touch) {\r\n        this.swiper = new swiper(`#${this.element.id}`, \"carousel\", \"pan-y\");\r\n        this.swiper\r\n          .onSwipeStart(this.swipestart.bind(this))\r\n          .onSwipeMove(this.swipemove.bind(this))\r\n          .onSwipeEnd(this.swipeend.bind(this));\r\n      }\r\n\r\n      if (this.options.keyboard) {\r\n        $d.on(this.element, \"keydown\", null, this.keydown.bind(this));\r\n      }\r\n\r\n      $d.on(\r\n        d,\r\n        this.options.keyboard ? [\"click\", \"keydown\"] : \"click\",\r\n        `[aria-controls=${this.element.id}]`,\r\n        this.click.bind(this)\r\n      );\r\n\r\n      if (this.interval) {\r\n        this.pause().cycle();\r\n      }\r\n    }\r\n\r\n    activeIndex() {\r\n      return this.items.findIndex(i => $d.hasClass(i, cactive));\r\n    }\r\n\r\n    lazyimages(slide) {\r\n      if (!core.data(slide)[\"lazyLoaded\"]) {\r\n        $d.queryAll(\"img[data-src]\", slide).forEach(s => {\r\n          if (s.src.length === 0) {\r\n            s.src = $d.getAttr(s, \"data-src\");\r\n          }\r\n        });\r\n\r\n        core.data(slide)[\"lazyLoaded\"] = true;\r\n      }\r\n    }\r\n\r\n    pause(event) {\r\n      if (!event) {\r\n        // Mark as paused\r\n        this.paused = true;\r\n      }\r\n\r\n      // Ensure that transition end is triggered.\r\n      if (\r\n        $d.queryAll(\".next, .prev\", this.element).length &&\r\n        core.support.transition\r\n      ) {\r\n        $d.trigger(this.element, core.support.transition);\r\n        this.cycle(true);\r\n      }\r\n\r\n      // Clear the interval and return the carousel for chaining.\r\n      this.interval = core.clearInterval(this.interval);\r\n\r\n      return this;\r\n    }\r\n\r\n    cycle(event) {\r\n      if (!event) {\r\n        // Flag false when there's no event.\r\n        this.paused = false;\r\n      }\r\n\r\n      if (this.interval) {\r\n        core.clearInterval(this.interval);\r\n      }\r\n\r\n      if (this.options.interval && !this.paused) {\r\n        // Cycle to the next item on the set interval\r\n        this.interval = core.setInterval(\r\n          this.next.bind(this),\r\n          this.options.interval\r\n        );\r\n      }\r\n\r\n      return this;\r\n    }\r\n\r\n    to(index) {\r\n      const activeIndex = this.activeIndex();\r\n\r\n      if (index > this.items.length - 1 || index < 0) {\r\n        return;\r\n      }\r\n\r\n      if (this.sliding) {\r\n        $d.one(this.element, this.eslid, null, () => {\r\n          this.to(index);\r\n        });\r\n        return;\r\n      }\r\n\r\n      if (activeIndex === index) {\r\n        this.pause().cycle();\r\n        return;\r\n      }\r\n\r\n      this.slide(index > activeIndex ? \"next\" : \"prev\", this.items[index]);\r\n    }\r\n\r\n    next() {\r\n      if (this.sliding) {\r\n        return false;\r\n      }\r\n\r\n      return this.slide(\"next\");\r\n    }\r\n\r\n    prev() {\r\n      if (this.sliding) {\r\n        return false;\r\n      }\r\n\r\n      return this.slide(\"prev\");\r\n    }\r\n\r\n    swipestart() {\r\n      if (this.sliding || this.items.length === 1) {\r\n        return;\r\n      }\r\n\r\n      if (this.interval) {\r\n        this.pause();\r\n      }\r\n    }\r\n\r\n    swipemove(event) {\r\n      // Left is next in LTR mode.\r\n      let left = event.detail.delta.x < 0,\r\n        type = this.rtl ? (left ? \"prev\" : \"next\") : left ? \"next\" : \"prev\",\r\n        isNext = type === \"next\",\r\n        fallback = isNext ? 0 : this.items.length - 1,\r\n        activeIndex = this.activeIndex(),\r\n        activeItem = this.items[activeIndex];\r\n\r\n      let nextItem = $d[type](activeItem, citems);\r\n\r\n      // Work out which item to slide to.\r\n      if (!nextItem) {\r\n        if (!this.options.wrap) {\r\n          return;\r\n        }\r\n\r\n        nextItem = this.items[fallback];\r\n      }\r\n\r\n      if ($d.hasClass(nextItem, cactive)) {\r\n        return;\r\n      }\r\n\r\n      const notActive = this.items.filter(\r\n        i => i !== activeItem && i !== nextItem\r\n      );\r\n      $d.setStyle(notActive, { left: \"\", right: \"\", opacity: \"\" });\r\n\r\n      if (this.options.lazyImages && this.options.lazyOnDemand) {\r\n        // Load the next image.\r\n        this.lazyimages(nextItem);\r\n      }\r\n\r\n      // Get the distance swiped as a percentage.\r\n      let width = parseInt(w.getComputedStyle(activeItem).width, 10),\r\n        percent = parseFloat((event.detail.delta.x / width) * 100),\r\n        diff = isNext ? 100 : -100;\r\n\r\n      if (this.rtl) {\r\n        percent *= -1;\r\n      }\r\n\r\n      // Swipe behaviour changes direction in rtl mode.\r\n      w.requestAnimationFrame(() => {\r\n        // Frustratingly can't be added on swipe start since edge triggers that on \"click\"\r\n        $d.addClass(this.element, \"no-transition\");\r\n\r\n        if (this.options.mode === \"slide\") {\r\n          if (this.rtl) {\r\n            $d.setStyle(activeItem, { right: percent + \"%\" });\r\n\r\n            $d.addClass(nextItem, type);\r\n            $d.setStyle(nextItem, { right: percent + diff + \"%\" });\r\n          } else {\r\n            $d.setStyle(activeItem, { left: percent + \"%\" });\r\n\r\n            $d.addClass(nextItem, type);\r\n            $d.setStyle(nextItem, { left: percent + diff + \"%\" });\r\n          }\r\n        } else {\r\n          $d.setStyle(activeItem, { opacity: 1 - Math.abs(percent / 100) });\r\n          $d.addClass(nextItem, type);\r\n        }\r\n      });\r\n    }\r\n\r\n    swipeend(event) {\r\n      if (this.sliding || !$d.hasClass(this.element, \"no-transition\")) {\r\n        return;\r\n      }\r\n\r\n      const left = event.detail.direction === \"left\",\r\n        method = this.rtl ? (left ? \"prev\" : \"next\") : left ? \"next\" : \"prev\";\r\n\r\n      // Re-enable the transitions.\r\n      $d.removeClass(this.element, \"no-transition\");\r\n      if (core.support.transition) {\r\n        // Trim the animation duration based on the current position.\r\n        const activeIndex = this.activeIndex(),\r\n          activeItem = this.items[activeIndex],\r\n          style = w.getComputedStyle(activeItem);\r\n\r\n        if (!this.translationDuration) {\r\n          this.translationDuration = parseFloat(style.transitionDuration);\r\n        }\r\n\r\n        // Get the distance and turn it into a percentage\r\n        // to calculate the duration. Whichever is lowest is used.\r\n        const width = parseInt(style.width, 10),\r\n          percentageTravelled = (Math.abs(event.detail.delta.x) / width) * 100,\r\n          swipeDuration =\r\n            ((event.detail.duration / 1000) * 100) / percentageTravelled,\r\n          newDuration =\r\n            ((100 - percentageTravelled) / 100) *\r\n            Math.min(this.translationDuration, swipeDuration);\r\n\r\n        // Set the new temporary duration.\r\n        $d.setStyle(this.items, { \"transition-duration\": `${newDuration}s` });\r\n      }\r\n\r\n      this.slide(method);\r\n    }\r\n\r\n    keydown(event) {\r\n      if (!event || /input|textarea/i.test(event.target.tagName)) {\r\n        return;\r\n      }\r\n\r\n      const which = event.which;\r\n      if (which === core.keys.LEFT || which === core.keys.RIGHT) {\r\n        this.keyboardTriggered = true;\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n\r\n        // Seek out the correct direction indicator, shift, and focus.\r\n        switch (which) {\r\n          case core.keys.LEFT:\r\n            if (this.rtl) {\r\n              this.next();\r\n              this.nextTrigger.focus();\r\n            } else {\r\n              this.prev();\r\n              this.prevTrigger.focus();\r\n            }\r\n            break;\r\n          case core.keys.RIGHT:\r\n            if (this.rtl) {\r\n              this.prev();\r\n              this.prevTrigger.focus();\r\n            } else {\r\n              this.next();\r\n              this.nextTrigger.focus();\r\n            }\r\n            break;\r\n        }\r\n      }\r\n    }\r\n\r\n    click(event) {\r\n      if (!event) {\r\n        return;\r\n      }\r\n\r\n      const which = event.which;\r\n      if (which && which !== core.keys.CLICK) {\r\n        if (which === core.keys.SPACE || which === core.keys.ENTER) {\r\n          this.keyboardTriggered = true;\r\n        } else {\r\n          return;\r\n        }\r\n      }\r\n\r\n      event.preventDefault();\r\n      event.stopPropagation();\r\n\r\n      if (event.target === this.nextTrigger) {\r\n        this.next();\r\n      } else if (event.target === this.prevTrigger) {\r\n        this.prev();\r\n      } else {\r\n        this.to(this.indicators.findIndex(i => i === event.target));\r\n      }\r\n    }\r\n\r\n    slide(type, next) {\r\n      let activeItem = this.items[this.activeIndex()],\r\n        nextItem = next || $d[type](activeItem, citems),\r\n        isCycling = this.interval,\r\n        isNext = type === \"next\",\r\n        fallback = isNext ? 0 : this.items.length - 1;\r\n\r\n      if (isCycling) {\r\n        // Pause if cycling.\r\n        this.pause();\r\n      }\r\n\r\n      // Work out which item to slide to.\r\n      if (!nextItem) {\r\n        if (!this.options.wrap) {\r\n          return;\r\n        }\r\n\r\n        nextItem = this.items[fallback];\r\n      }\r\n\r\n      if ($d.hasClass(nextItem, cactive)) {\r\n        return (this.sliding = false);\r\n      }\r\n\r\n      const direction = isNext ? \"left\" : \"right\";\r\n      const edirection = this.rtl\r\n        ? isNext\r\n          ? \"right\"\r\n          : \"left\"\r\n        : isNext\r\n        ? \"left\"\r\n        : \"right\";\r\n\r\n      if (\r\n        !$d.trigger(this.element, this.eslide, {\r\n          relatedTarget: nextItem,\r\n          direction: edirection\r\n        })\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      if (this.options.lazyImages && this.options.lazyOnDemand) {\r\n        // Load the next image.\r\n        this.lazyimages(nextItem);\r\n      }\r\n\r\n      // Good to go? Then let's slide.\r\n      this.sliding = true;\r\n\r\n      $d.one(this.element, this.eslid, null, () => {\r\n        const activeIndex = this.activeIndex();\r\n        if (!this.options.wrap) {\r\n          if (activeIndex === this.items.length - 1) {\r\n            $d.setAttr(this.nextTrigger, { \"aria-hidden\": true, hidden: true });\r\n            $d.removeAttr(this.prevTrigger, [\"aria-hidden\", \"hidden\"]);\r\n            if (this.keyboardTriggered) {\r\n              this.prevTrigger.focus();\r\n              this.keyboardTriggered = false;\r\n            }\r\n          } else if (activeIndex === 0) {\r\n            $d.setAttr(this.prevTrigger, { \"aria-hidden\": true, hidden: true });\r\n            $d.removeAttr(this.nextTrigger, [\"aria-hidden\", \"hidden\"]);\r\n            if (this.keyboardTriggered) {\r\n              this.nextTrigger.focus();\r\n              this.keyboardTriggered = false;\r\n            }\r\n          } else {\r\n            $d.removeAttr(this.prevTrigger, [\"aria-hidden\", \"hidden\"]);\r\n            $d.removeAttr(this.nextTrigger, [\"aria-hidden\", \"hidden\"]);\r\n            this.keyboardTriggered = false;\r\n          }\r\n        }\r\n\r\n        // Highlight the correct indicator.\r\n        $d.removeClass(this.indicators, \"active\");\r\n        $d.addClass(this.indicators[activeIndex], \"active\");\r\n      });\r\n\r\n      const complete = () => {\r\n        $d.removeClass(activeItem, [cactive, direction]);\r\n        $d.setAttr(activeItem, { \"aria-selected\": false, tabIndex: -1 });\r\n\r\n        // We have to undo left etc twice. I don't know why.\r\n        $d.setStyle(this.items, {\r\n          \"transition-duration\": \"\",\r\n          left: \"\",\r\n          right: \"\",\r\n          opacity: \"\"\r\n        });\r\n\r\n        $d.removeClass(nextItem, [type, direction]);\r\n        $d.addClass(nextItem, cactive);\r\n        $d.setAttr(nextItem, { \"aria-selected\": true, tabIndex: 0 });\r\n\r\n        this.sliding = false;\r\n        $d.trigger(this.element, this.eslid, {\r\n          relatedTarget: nextItem,\r\n          direction: edirection\r\n        });\r\n\r\n        // Restart the cycle.\r\n        if (isCycling) {\r\n          this.cycle();\r\n        }\r\n      };\r\n\r\n      // Force reflow.\r\n      $d.addClass(nextItem, type);\r\n      core.redraw(nextItem);\r\n\r\n      // Do the slide and clear the added styles.\r\n      core.onTransitionEnd(activeItem, complete);\r\n      $d.addClass(activeItem, direction);\r\n      $d.addClass(nextItem, direction);\r\n      $d.setStyle(this.items, { left: \"\", right: \"\", opacity: \"\" });\r\n      return this;\r\n    }\r\n  }\r\n\r\n  // Register plugin and data-api event handler and return\r\n  return core.registerDataApi(RbpCarousel, \"carousel\", defaults);\r\n})($d, Swiper, RbpCore, RbpBase, window, document);\r\n\r\nexport default RbpCarousel;\r\n","import $d from \"./dum\"\r\nimport RbpBase from \"./base\"\r\nimport RbpCore from \"./core\"\r\n\r\nconst RbpConditional = (($d, core, base) => {\r\n\r\n    const defaults = {\r\n        xxs: null,\r\n        xs: null,\r\n        s: null,\r\n        m: null,\r\n        l: null,\r\n        fallback: null,\r\n        error: \"<p>An error has occured.</p>\"\r\n    };\r\n\r\n    class RbpConditional extends base {\r\n        constructor(element, options) {\r\n            super(element, defaults, options, \"conditional\");\r\n\r\n            this.eload = \"load.rbp\";\r\n            this.eloaded = \"loaded.rbp\";\r\n            this.eerror = \"error.rbp\";\r\n\r\n            this.cache = {};\r\n            this.currentGrid = null;\r\n            this.currentTarget = null;\r\n            this.loading = false;\r\n\r\n            // Bind events.\r\n            $d.on(window, \"resize\", null, core.debounce(this.resize.bind(this), 50));\r\n\r\n            // First Run\r\n            this.resize();\r\n        }\r\n\r\n        resize() {\r\n            const current = core.currentGrid(),\r\n                grid = current.grid,\r\n                range = current.range;\r\n\r\n            if (this.currentGrid === grid) {\r\n                return;\r\n            }\r\n\r\n            // Check to see if we need to cache the current content.\r\n            if (!this.options.fallback) {\r\n                range.forEach(r => {\r\n                    if (!this.options[r]) {\r\n                        this.options[r] = \"fallback\";\r\n                        this.cache[r] = this.element.innerHTML;\r\n                    }\r\n                });\r\n            }\r\n\r\n            this.currentGrid = grid;\r\n            const target = this.options[grid] || this.options.fallback;\r\n\r\n            if (target === this.currentTarget) {\r\n                return;\r\n            }\r\n\r\n            this.currentTarget = target;\r\n\r\n            if (this.loading || !$d.trigger(this.element, this.eload)) {\r\n                return;\r\n            }\r\n\r\n            this.loading = true;\r\n\r\n            // First check the cache.\r\n            if (this.cache[this.currentGrid]) {\r\n                $d.empty(this.element);\r\n                this.element.innerHTML = this.cache[this.currentGrid];\r\n                this.loading = false;\r\n                $d.trigger(this.element, this.eloaded, { relatedTarget: this.element, loadTarget: target, grid: this.currentGrid })\r\n                return;\r\n            }\r\n\r\n            const detail = { relatedTarget: this.element, loadTarget: target, grid: this.currentGrid };\r\n            $d.empty(this.element);\r\n\r\n            core.loadHtml(target).then(html => {\r\n                this.loading = false;\r\n                // Convert to a string for storage, empty() already deals with any event handlers.\r\n                html = html.outerHTML;\r\n                this.cache[grid] = html;\r\n                this.element.innerHTML = html;\r\n                $d.trigger(this.element, this.eloaded, detail);\r\n            }).catch(e => {\r\n                $d.trigger(this.element, this.eerror, Object.assign({}, detail, { error: e, }));\r\n                this.element.innerHTML = this.options.error;\r\n                this.loading = false;\r\n            });\r\n        }\r\n    }\r\n\r\n    // Register plugin and data-api event handler and return\r\n    return core.registerDataApi(RbpConditional, \"conditional\", defaults);\r\n\r\n})($d, RbpCore, RbpBase);\r\n\r\nexport default RbpConditional;","import $d from \"./dum\";\r\n\r\n/**!\r\n * Responsive v5.0.0 | MIT License | responsivebp.com\r\n */\r\nconst RbpCore = (($d, w, d) => {\r\n  // The initialization event used to trigger component autoloading\r\n  const einit = \"init.rpb\";\r\n\r\n  const raf = w.requestAnimationFrame;\r\n\r\n  const okeys = Object.keys;\r\n\r\n  const support = {\r\n    touchEvents:\r\n      \"ontouchstart\" in w ||\r\n      (w.DocumentTouch && document instanceof w.DocumentTouch),\r\n    pointerEvents: w.PointerEvent\r\n  };\r\n\r\n  support.transition = (() => {\r\n    const transitionEnd = () => {\r\n      const div = $d.create(\"div\"),\r\n        transEndEventNames = {\r\n          transition: \"transitionend\",\r\n          WebkitTransition: \"webkitTransitionEnd\"\r\n        };\r\n\r\n      const names = okeys(transEndEventNames);\r\n      for (let i = 0; i < names.length; i++) {\r\n        if (div.style[names[i]] !== undefined) {\r\n          return transEndEventNames[names[i]];\r\n        }\r\n      }\r\n\r\n      return null;\r\n    };\r\n\r\n    return transitionEnd();\r\n  })();\r\n\r\n  const getDurationMs = element =>\r\n    w.getComputedStyle(element).transitionDuration.match(/\\d+(.\\d+)?/)[0] *\r\n    1000;\r\n\r\n  const dataMap = new WeakMap();\r\n\r\n  const rdashAlpha = /-([a-z])/g;\r\n\r\n  const fcamelCase = (all, letter) => letter.toUpperCase();\r\n\r\n  /**\r\n   * Contains information about the current viewport grid definition\r\n   * @class Grid\r\n   */\r\n  class Grid {\r\n    constructor(grid, index, range) {\r\n      /**\r\n       * The grid The current applied grid; either xxs, xs, s, m, or l\r\n       * @type {string}\r\n       */\r\n      this.grid = grid;\r\n\r\n      /**\r\n       * The index of the current grid in the range\r\n       * @type {number}\r\n       */\r\n      this.index = index;\r\n\r\n      /**\r\n       * The available grid range\r\n       * @type {string[]}\r\n       */\r\n      this.range = range;\r\n    }\r\n  }\r\n\r\n  class RbpCore {\r\n    constructor() {\r\n      this.support = support;\r\n      this.einit = einit;\r\n\r\n      this.keys = {\r\n        CLICK: 1, // Not really a keyboard event but get passed via which\r\n        ENTER: 13,\r\n        ESCAPE: 27,\r\n        SPACE: 32,\r\n        LEFT: 37,\r\n        RIGHT: 39\r\n      };\r\n\r\n      this.fn = {\r\n        on: [],\r\n        off: function(api) {\r\n          if (api === \"data-api\") {\r\n            this.on.forEach(k => {\r\n              $d.off(d, einit + \".\" + this.on[k]);\r\n              this.on.splice(k, 1);\r\n            });\r\n            return;\r\n          }\r\n\r\n          const i = this.on.indexOf(api);\r\n          if (i > -1) {\r\n            $d.off(d, einit + \".\" + this.on[i]);\r\n            this.on.splice(i, 1);\r\n          }\r\n        },\r\n        support: support\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Generates a unique eight character random string prefixed with `uid-`\r\n     * @returns {string}\r\n     * @memberof RbpCore\r\n     */\r\n    uid() {\r\n      const chars =\r\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\r\n      let id = \"\";\r\n\r\n      for (let i = 0; i < 8; i++) {\r\n        id += chars.charAt(Math.floor(Math.random() * chars.length));\r\n      }\r\n\r\n      return `uid-${id}`;\r\n    }\r\n\r\n    /**\r\n     * Returns a transformed string in camel case format\r\n     * @param {string} value The string to alter\r\n     * @returns {string}\r\n     * @memberof RbpCore\r\n     */\r\n    camelCase(value) {\r\n      const noDash = value.replace(rdashAlpha, fcamelCase);\r\n      return noDash.charAt(0).toLowerCase() + noDash.substring(1);\r\n    }\r\n\r\n    /**\r\n     * Returns a transformed string in dashed case format\r\n     * @param {string} value The string to alter\r\n     * @returns {string}\r\n     * @memberof RbpCore\r\n     */\r\n    dashedCase(value) {\r\n      return value.replace(/([A-Z])/g, $1 => `-${$1.toLowerCase()}`);\r\n    }\r\n\r\n    /**\r\n     * Returns a namespaced data attribute CSS selector from the given default options\r\n     * @param {any} defaults\r\n     * @param {any} namespace\r\n     * @returns\r\n     * @memberof RbpCore\r\n     */\r\n    dataSelector(defaults, namespace) {\r\n      return (\r\n        (defaults &&\r\n          `${okeys(defaults)\r\n            .map(x => `[data-${namespace}-${this.dashedCase(x)}]`)\r\n            .join(\", \")}`) ||\r\n        `[data-${namespace}]`\r\n      );\r\n    }\r\n\r\n    /**\r\n     * Registers the given plugin against the data-api using the given namespace and defaults\r\n     * @param {Class} plugin The plugin type\r\n     * @param {any} namespace The data-api namespace\r\n     * @param {object} defaults The object containing the default data-attribute keys\r\n     * @returns {Class} the plugin type\r\n     * @memberof RbpCore\r\n     */\r\n    registerDataApi(plugin, namespace, defaults) {\r\n      if (this.fn[namespace]) {\r\n        return;\r\n      }\r\n\r\n      this.fn[namespace] = [];\r\n\r\n      this.fn[namespace] = (e, o) => {\r\n        let result = [];\r\n\r\n        $d.queryAll(e).forEach(i => {\r\n          return result.push(\r\n            this.data(i)[namespace] ||\r\n              (this.data(i)[namespace] = new plugin(i, o))\r\n          );\r\n        });\r\n\r\n        return result.length === 1 ? result[0] : result;\r\n      };\r\n\r\n      this.fn.on.push(`${namespace}.data-api`);\r\n      $d.on(d, this.einit + \".\" + `${namespace}.data-api`, null, () => {\r\n        this.fn[namespace](this.dataSelector(defaults, namespace));\r\n      });\r\n\r\n      return plugin;\r\n    }\r\n\r\n    /**\r\n     * Returns any data stored in data-attributes for the given element\r\n     * @param {HTMLElement} element\r\n     * @returns {object}\r\n     * @memberof RbpCore\r\n     */\r\n    data(element) {\r\n      if (!dataMap.has(element)) {\r\n        let attr = {},\r\n          data = Object.values(element.attributes).filter(\r\n            a => a.name.indexOf(\"data-\") === 0\r\n          );\r\n\r\n        data.forEach(d => {\r\n          attr[this.camelCase(d.name.slice(5))] = d.value;\r\n        });\r\n\r\n        dataMap.set(element, { attr: attr });\r\n      }\r\n\r\n      return dataMap.get(element);\r\n    }\r\n\r\n    /**\r\n     * Returns a value indicating what grid range the current browser width is within.\r\n     * @returns {Grid}\r\n     * @memberof RbpCore\r\n     */\r\n    currentGrid() {\r\n      const div = $d.create(\"div\");\r\n      $d.addClass(div, \"gsi\");\r\n      $d.prepend(d.body, div);\r\n\r\n      // These numbers match values in the css\r\n      const grids = [\"xxs\", \"xs\", \"s\", \"m\", \"l\"],\r\n        key = parseInt(w.getComputedStyle(div).width, 10);\r\n\r\n      div.remove();\r\n\r\n      return new Grid(grids[key], key, grids);\r\n    }\r\n\r\n    /**\r\n     * Returns a value indicating whether the given element is within a right-to-left context\r\n     * @param {HTMLElement} element\r\n     * @returns {boolean}\r\n     * @memberof RbpCore\r\n     */\r\n    isRtl(element) {\r\n      return Boolean(element.closest(\"[dir=rtl]\"));\r\n    }\r\n\r\n    /**\r\n     * Returns a value indicating whether the given element both hidden from display and layout in the DOM\r\n     * @param {HTMLElement} element\r\n     * @returns {boolean}\r\n     * @memberof RbpCore\r\n     */\r\n    isHidden(element) {\r\n      const visible = Boolean(\r\n        element.offsetWidth ||\r\n          element.offsetHeight ||\r\n          element.getClientRects().length\r\n      );\r\n      return !visible;\r\n    }\r\n\r\n    /**\r\n     * Forces the browser to redraw given element\r\n     * @param {HTMLElement} element\r\n     * @memberof RbpCore\r\n     */\r\n    redraw(element) {\r\n      return element && element.offsetWidth;\r\n    }\r\n\r\n    /**\r\n     * Returns the document or element from the given url\r\n     * @param {any} url The path to the target document. if a space prefixed `#selector` is appended to the url then\r\n     * the element matching that selector will be returned.\r\n     * @returns {HtmlDocument | HtmlElement}\r\n     * @memberof RbpCore\r\n     */\r\n    loadHtml(url) {\r\n      const parts = url.split(/\\s+/),\r\n        selector = parts.length > 1 ? parts[1].trim() : null;\r\n      url = parts[0];\r\n\r\n      return fetch(url)\r\n        .then(response => {\r\n          if (!response.ok) {\r\n            throw Error(response.statusText);\r\n          }\r\n          return response.text();\r\n        })\r\n        .then(data => {\r\n          return $d.fromHtml(data, selector);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns a function, that, as long as it continues to be invoked, will not\r\n     * be triggered. The function will be called after it stops being called for\r\n     * N milliseconds. If `immediate` is passed, trigger the function on the\r\n     * leading edge, instead of the trailing.\r\n     * @param {Function} func The function to debounce\r\n     * @param {number} wait The number of milliseconds to delay\r\n     * @param {boolean} immediate Specify execution on the leading edge of the timeout\r\n     * @returns {Function}\r\n     * @memberof RbpCore\r\n     */\r\n    debounce(func, wait, immediate) {\r\n      let timeout;\r\n      return function() {\r\n        const args = arguments;\r\n        w.clearTimeout(timeout);\r\n        timeout = this.setTimeout(() => {\r\n          timeout = null;\r\n          if (!immediate) {\r\n            func.apply(this, args);\r\n          }\r\n        }, wait);\r\n        if (immediate && !timeout) {\r\n          func.apply(this, args);\r\n        }\r\n      };\r\n    }\r\n\r\n    /**\r\n     * An enhanced version of `window.setInterval` that uses the enhanced performance and accuracy offered by\r\n     * `window.requestAnimationFrame`.\r\n     * see https://github.com/nk-components/request-interval\r\n     * @param {Function} func A function to be executed every delay milliseconds.\r\n     * @param {number} delay The delay in milliseconds\r\n     * The function is not passed any parameters, and no return value is expected.\r\n     * @returns {object}\r\n     * @memberof RbpCore\r\n     */\r\n    setInterval(func, delay) {\r\n      let start = Date.now(),\r\n        handler = { id: raf(loop) };\r\n\r\n      return handler;\r\n\r\n      function loop() {\r\n        handler.id = raf(loop);\r\n\r\n        if (Date.now() - start >= delay) {\r\n          func();\r\n          start = Date.now();\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * An enhanced version of `window.clearInterval` that uses the enhanced performance and accuracy offered by\r\n     * `window.cancelAnimationFrame`.\r\n     * @param {object} handler The handler returned by th previous `setInterval` call\r\n     * @memberof RbpCore\r\n     */\r\n    clearInterval(handler) {\r\n      handler && w.cancelAnimationFrame(handler.id);\r\n    }\r\n\r\n    /**\r\n     * An enhanced version of `window.setTimeout` that uses the enhanced performance and accuracy offered by\r\n     * `window.requestAnimationFrame`.\r\n     * @param {Function} func A function to be executed after delay milliseconds.\r\n     * @param {number} delay The delay in milliseconds\r\n     * @returns\r\n     * @memberof RbpCore\r\n     */\r\n    setTimeout(func, delay) {\r\n      let start = Date.now(),\r\n        handler = { id: raf(loop) };\r\n\r\n      return handler;\r\n\r\n      function loop() {\r\n        Date.now() - start >= delay ? func() : (handler.id = raf(loop));\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Binds a one-time event handler to the element that is triggered on CSS transition end\r\n     * ensuring that the event is always triggered after the correct duration.\r\n     * @param {HTMLElement} element The element to bind to\r\n     * @param {Function} func The callback function\r\n     * @memberof RbpCore\r\n     */\r\n    onTransitionEnd(element, func) {\r\n      const supportTransition = this.support.transition;\r\n\r\n      if (!supportTransition) {\r\n        func();\r\n        return;\r\n      }\r\n\r\n      // Register the eventhandler that calls the defined callback\r\n      let called = false;\r\n      $d.one(element, supportTransition, null, () => {\r\n        if (!called) {\r\n          called = true;\r\n          func();\r\n        }\r\n      });\r\n\r\n      // Ensure that the event is always triggered.\r\n      const ensure = function() {\r\n        if (!called) {\r\n          $d.trigger(element, supportTransition);\r\n        }\r\n      };\r\n      this.setTimeout(ensure, getDurationMs(element));\r\n    }\r\n  }\r\n\r\n  // Create our core instance and bind to the window\r\n  const core = new RbpCore();\r\n  w.$rbp = core.fn;\r\n\r\n  // Register the data event handlers on ready\r\n  $d.ready().then(() => {\r\n    // Trigger the einit event\r\n    $d.trigger(d, core.einit);\r\n\r\n    // Observe for future changes in the DOM\r\n    new MutationObserver(() => {\r\n      $d.trigger(d, einit);\r\n    }).observe(d.body, {\r\n      childList: true,\r\n      subtree: true\r\n    });\r\n  });\r\n\r\n  // Return\r\n  return core;\r\n})($d, window, document);\r\n\r\nexport default RbpCore;\r\n","import $d from \"./dum\";\r\nimport RbpBase from \"./base\";\r\nimport RbpCore from \"./core\";\r\n\r\nconst RbpDismiss = (($d, core, base) => {\r\n  const defaults = { hint: \"Click to close\", target: \"\" };\r\n  class RbpDismiss extends base {\r\n    constructor(element, options) {\r\n      super(element, defaults, options, \"dismiss\");\r\n\r\n      this.eDismiss = \"dismiss.rbp.dismiss\";\r\n      this.eDismissed = \"dismissed.rbp.dismiss\";\r\n      this.dismissing = false;\r\n      this.target = this.element.closest(this.options.target);\r\n\r\n      // A11y\r\n      $d.setAttr(this.element, { type: \"button\" });\r\n      if (this.target.classList.contains(\"alert\")) {\r\n        $d.setAttr(this.target, { role: \"alert\" });\r\n      }\r\n\r\n      if (!$d.queryAll(\".vhidden\", this.element).length) {\r\n        let span = $d.create(\"span\");\r\n        $d.addClass(span, \"vhidden\");\r\n        span.innerHTML = this.options.hint;\r\n        this.element.appendChild(span);\r\n      }\r\n\r\n      $d.on(this.element, \"click\", null, this.click.bind(this));\r\n    }\r\n\r\n    close() {\r\n      if (this.dismissing || !$d.trigger(this.element, this.eDismiss)) {\r\n        return;\r\n      }\r\n\r\n      this.dismissing = true;\r\n\r\n      const complete = () => {\r\n        $d.removeClass(this.target, \"fade-out\");\r\n        $d.setAttr(this.target, {\r\n          \"aria-hidden\": true,\r\n          hidden: true,\r\n          tabindex: -1\r\n        });\r\n        $d.trigger(this.element, this.eDismissed);\r\n      };\r\n\r\n      $d.addClass(this.target, \"fade-in fade-out\");\r\n      core.onTransitionEnd(this.target, complete);\r\n      core.redraw(this.target);\r\n      $d.removeClass(this.target, \"fade-in\");\r\n    }\r\n\r\n    click(event) {\r\n      event.preventDefault();\r\n      this.close();\r\n    }\r\n  }\r\n\r\n  // Register plugin and data-api event handler and return\r\n  return core.registerDataApi(RbpDismiss, \"dismiss\", defaults);\r\n})($d, RbpCore, RbpBase);\r\n\r\nexport default RbpDismiss;\r\n","import $d from \"./dum\";\r\nimport RbpBase from \"./base\";\r\nimport RbpCore from \"./core\";\r\n\r\nconst RbpDropdown = (($d, core, base) => {\r\n  const defaults = { dimension: \"height\", target: null, parent: null };\r\n  class RbpDropdown extends base {\r\n    constructor(element, options) {\r\n      super(element, defaults, options, \"dropdown\");\r\n\r\n      const namespace = \".rbp.dropdown\";\r\n      this.eshow = `show${namespace}`;\r\n      this.eshown = `shown${namespace}`;\r\n      this.ehide = `hide${namespace}`;\r\n      this.ehidden = `hidden${namespace}`;\r\n\r\n      this.rtl = core.isRtl(this.element);\r\n      this.target = $d.query(this.options.target);\r\n      this.parent = null;\r\n      this.transitioning = false;\r\n      this.endSize = null;\r\n\r\n      const paneId = (this.target.id = this.target.id || core.uid()),\r\n        active = !$d.hasClass(this.target, \"collapse\");\r\n\r\n      $d.setAttr(this.element, {\r\n        role: \"tab\",\r\n        \"aria-controls\": paneId,\r\n        \"aria-selected\": active,\r\n        \"aria-expanded\": active,\r\n        tabindex: 0\r\n      });\r\n\r\n      if (this.options.parent) {\r\n        this.parent = this.target.closest(this.options.parent);\r\n        $d.setAttr(this.parent, {\r\n          role: \"tablist\",\r\n          \"aria-multiselectable\": \"true\"\r\n        });\r\n\r\n        // We're safe to add the attribute here since if it's not used when data-api is disabled.\r\n        $d.setAttr(this.element, {\r\n          \"data-dropdown-parent\": this.options.parent\r\n        });\r\n      }\r\n\r\n      $d.setAttr(this.target, {\r\n        role: \"tabpanel\",\r\n        \"aria-labelledby\": this.element.id,\r\n        \"aria-hidden\": !active,\r\n        tabindex: active ? 0 : -1\r\n      });\r\n\r\n      if (!active) {\r\n        $d.setAttr(this.target, { hidden: true });\r\n      }\r\n\r\n      // Bind events.\r\n      $d.on(this.element, \"click\", null, this.click.bind(this));\r\n      $d.on(this.element, \"keydown\", null, this.keydown.bind(this));\r\n    }\r\n\r\n    transition(method, startEvent, completeEvent, eventData) {\r\n      const doShow = method === \"removeClass\",\r\n        complete = () => {\r\n          // Ensure the height/width is set to auto.\r\n          $d.setStyle(this.target, { [this.options.dimension]: \"\" });\r\n\r\n          // Set the correct aria attributes.\r\n          $d.setAttr(this.target, {\r\n            \"aria-hidden\": !doShow,\r\n            tabindex: doShow ? 0 : -1\r\n          });\r\n\r\n          if (!doShow) {\r\n            $d.setAttr(this.target, { hidden: true });\r\n          }\r\n\r\n          let tab = $d.id($d.getAttr(this.target, \"aria-labelledby\"));\r\n          $d.setAttr(tab, { \"aria-selected\": doShow, \"aria-expanded\": doShow });\r\n\r\n          if (doShow) {\r\n            tab.focus();\r\n          }\r\n\r\n          this.transitioning = false;\r\n\r\n          $d.trigger(this.element, completeEvent, {\r\n            relatedTarget: this.options.target\r\n          });\r\n        };\r\n\r\n      if (!$d.trigger(this.element, startEvent, eventData)) {\r\n        return;\r\n      }\r\n\r\n      // Remove or add the expand classes.\r\n      core.onTransitionEnd(this.target, complete);\r\n      $d[method](this.target, \"collapse\");\r\n      $d[startEvent === this.eshow ? \"addClass\" : \"removeClass\"](\r\n        this.target,\r\n        \"expand\"\r\n      );\r\n      core.redraw(this.target);\r\n    }\r\n\r\n    show() {\r\n      if (this.transitioning || $d.hasClass(this.target, \"expand\")) {\r\n        return;\r\n      }\r\n\r\n      this.transitioning = true;\r\n\r\n      let dimension = this.options.dimension,\r\n        size,\r\n        actives = [];\r\n\r\n      if (this.parent) {\r\n        // Get all the related open panes.\r\n        actives = $d\r\n          .queryAll(`[data-dropdown-parent=\"${this.options.parent}\"]`)\r\n          .filter(a => {\r\n            let data = core.data(a).dropdown,\r\n              target = data && data.target;\r\n\r\n            return (\r\n              target &&\r\n              !$d.hasClass(target, \"collapse\") &&\r\n              data !== this &&\r\n              data.parent &&\r\n              data.parent === this.parent\r\n            );\r\n          });\r\n      }\r\n\r\n      // Set the height/width to zero then to the height/width so animation can take place.\r\n      $d.setStyle(this.target, { [dimension]: 0 });\r\n\r\n      if (core.support.transition) {\r\n        // Calculate the height/width.\r\n        $d.setStyle(this.target, { [dimension]: \"auto\" });\r\n        $d.setAttr(this.target, { \"aria-hidden\": false });\r\n        $d.removeAttr(this.target, \"hidden\");\r\n        size = window.getComputedStyle(this.target)[dimension];\r\n\r\n        // Reset to zero and force repaint.\r\n        $d.setStyle(this.target, { [dimension]: 0 });\r\n        core.redraw(this.target);\r\n      }\r\n\r\n      $d.setStyle(this.target, { [dimension]: size || \"\" });\r\n      this.transition(\"removeClass\", this.eshow, this.eshown, {\r\n        relatedTarget: this.options.target\r\n      });\r\n      actives.forEach(a => core.data(a).dropdown.hide());\r\n    }\r\n\r\n    hide() {\r\n      if (this.transitioning || this.target.classList.contains(\"collapse\")) {\r\n        return;\r\n      }\r\n\r\n      this.transitioning = true;\r\n\r\n      // Reset the height/width and then reduce to zero.\r\n      let dimension = this.options.dimension,\r\n        size;\r\n\r\n      if (core.support.transition) {\r\n        // Set the height to auto, calculate the height/width and reset.\r\n        size = window.getComputedStyle(this.target)[dimension];\r\n\r\n        // Reset the size and force repaint.\r\n        $d.setStyle(this.target, { [dimension]: size });\r\n        core.redraw(this.target);\r\n      }\r\n\r\n      this.transition(\"addClass\", this.ehide, this.ehidden, {\r\n        relatedTarget: this.options.target\r\n      });\r\n      $d.setStyle(this.target, { [dimension]: 0 });\r\n    }\r\n\r\n    toggle() {\r\n      if (this.transitioning) {\r\n        return;\r\n      }\r\n\r\n      this[this.target.classList.contains(\"collapse\") ? \"show\" : \"hide\"]();\r\n    }\r\n\r\n    click(event) {\r\n      event.preventDefault();\r\n      event.stopPropagation();\r\n      this.toggle();\r\n    }\r\n\r\n    keydown(event) {\r\n      if (/input|textarea/i.test(event.target.tagName)) {\r\n        return;\r\n      }\r\n\r\n      const which = event.which;\r\n      if (\r\n        which === core.keys.SPACE ||\r\n        which === core.keys.LEFT ||\r\n        which === core.keys.RIGHT\r\n      ) {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n      }\r\n\r\n      if (which === core.keys.SPACE) {\r\n        this.toggle();\r\n        return;\r\n      }\r\n\r\n      if (!this.parent) {\r\n        return;\r\n      }\r\n\r\n      let items = $d.queryAll(\r\n          `[data-dropdown-parent=\"${this.options.parent}\"]`\r\n        ),\r\n        index = items.findIndex(i => i.matches(\":focus\")),\r\n        length = items.length;\r\n\r\n      if (which === core.keys.LEFT) {\r\n        this.rtl ? (index += 1) : (index -= 1);\r\n      } else if (which === core.keys.RIGHT) {\r\n        this.rtl ? (index -= 1) : (index += 1);\r\n      }\r\n\r\n      // Ensure that the index stays within bounds.\r\n      if (index === length) {\r\n        index = 0;\r\n      }\r\n\r\n      if (index < 0) {\r\n        index = length - 1;\r\n      }\r\n\r\n      const data = core.data(items[index]).dropdown;\r\n      data && data.show();\r\n    }\r\n  }\r\n\r\n  // Register plugin and data-api event handler and return\r\n  return core.registerDataApi(RbpDropdown, \"dropdown\", defaults);\r\n})($d, RbpCore, RbpBase);\r\n\r\nexport default RbpDropdown;\r\n","/**!\r\n * DUM.js | MIT License | https://github.com/JimBobSquarePants/DUM.js\r\n */\r\n\r\nconst $d = ((w, d) => {\r\n  // Regular expressions\r\n  // Spaces\r\n  const rspace = /\\s+/;\r\n\r\n  // Array-like collections that we should slice\r\n  const rslice = /nodelist|htmlcollection/;\r\n\r\n  // Event namespace detection\r\n  const rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\r\n\r\n  const keys = Object.keys;\r\n\r\n  const domParser = new w.DOMParser();\r\n\r\n  const parseHtml = html => domParser.parseFromString(html, \"text/html\");\r\n\r\n  // Escape function for RexExp https://github.com/benjamingr/RegExp.escape\r\n  const escape = s => String(s).replace(/[\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\r\n\r\n  // Returns the type of an object in lowercase. Kudos Angus Croll\r\n  // https://javascriptweblog.wordpress.com/2011/08/08/fixing-the-javascript-typeof-operator/\r\n  const type = obj =>\r\n    ({}.toString\r\n      .call(obj)\r\n      .match(/\\s([a-zA-Z]+)/)[1]\r\n      .toLowerCase());\r\n\r\n  const isString = obj => type(obj) === \"string\";\r\n\r\n  const isArray = obj => type(obj) === \"array\";\r\n\r\n  const isFunc = obj => type(obj) === \"function\";\r\n\r\n  const isNullOrUndefined = obj => obj === null || obj === undefined;\r\n\r\n  // Convert, number, string, and collection types to an array\r\n  const toArray = obj => {\r\n    return (\r\n      (obj &&\r\n        (isArray(obj)\r\n          ? obj\r\n          : rslice.test(type(obj))\r\n          ? [].slice.call(obj)\r\n          : [obj])) ||\r\n      []\r\n    );\r\n  };\r\n\r\n  const arrayFunction = (items, delegate, args) => {\r\n    let result = [];\r\n    toArray(items).forEach(i => {\r\n      if (isNullOrUndefined(i)) {\r\n        return;\r\n      }\r\n      const r = delegate.apply(i, args);\r\n      result = result.concat(toArray(r));\r\n    });\r\n    return result;\r\n  };\r\n\r\n  const classAction = (elements, method, names) => {\r\n    (isArray(names) ? names : (names && names.split(rspace)) || []).forEach(\r\n      n => {\r\n        arrayFunction(elements, function() {\r\n          n && this.classList[method](n);\r\n        });\r\n      }\r\n    );\r\n  };\r\n\r\n  const insertAction = (elements, children, reverse, action) => {\r\n    children = toArray(children);\r\n    children = reverse ? children.reverse() : children;\r\n    let i = 0;\r\n    arrayFunction(elements, function() {\r\n      // If we are adding to multiple elements we need to clone\r\n      let clones = i > 0 ? children.map(c => c.cloneNode(true)) : children;\r\n      clones.forEach(c => action.call(this, c));\r\n      i++;\r\n    });\r\n  };\r\n\r\n  const sibling = (element, dir, expression) => {\r\n    // eslint-disable-next-line no-empty\r\n    while ((element = element[dir]) && !element.matches(expression)) {}\r\n    return element;\r\n  };\r\n\r\n  const doBind = (once, elements, events, selector, handler) => {\r\n    // Handle missing selector param\r\n    const hasSelector = isString(selector);\r\n    if (!hasSelector && !isFunc(handler)) {\r\n      handler = selector;\r\n    }\r\n\r\n    arrayFunction(elements, function() {\r\n      let el = this;\r\n      arrayFunction(events, function() {\r\n        Handler.on(\r\n          el,\r\n          this,\r\n          hasSelector ? selector : null,\r\n          handler,\r\n          hasSelector ? false : true,\r\n          once\r\n        );\r\n      });\r\n    });\r\n  };\r\n\r\n  // Handles the adding and removing of events.\r\n  // Events can be assigned to the element or delegated to a parent\r\n  const Handler = (() => {\r\n    const handlerMap = new WeakMap();\r\n    let i = 0;\r\n\r\n    const getHandlers = function(element, event, set) {\r\n      // Set if the event doesn't exist\r\n      if (set) {\r\n        if (!handlerMap.has(element)) {\r\n          let handlers = {\r\n            [event]: {}\r\n          };\r\n          handlerMap.set(element, handlers);\r\n        } else if (!handlerMap.get(element)[[event]]) {\r\n          let handlers = handlerMap.get(element);\r\n          handlers[[event]] = {};\r\n          handlerMap.set(element, handlers);\r\n        }\r\n\r\n        return handlerMap.get(element)[[event]];\r\n      }\r\n\r\n      // Get handlers matching type or namespace partial\r\n      if (handlerMap.has(element)) {\r\n        const namespaces = rtypenamespace.exec(event) || [];\r\n\r\n        let handlers = handlerMap.get(element);\r\n        for (const h of keys(handlers)) {\r\n          let len = namespaces.length;\r\n          while (len--) {\r\n            if (\r\n              namespaces[len] &&\r\n              new RegExp(`^${escape(h)}$`).exec(namespaces[len])\r\n            ) {\r\n              return handlers[h];\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return {};\r\n    };\r\n\r\n    // Bubbled event handling, one-time running\r\n    const handlerDelegate = (\r\n      selector,\r\n      handler,\r\n      element,\r\n      once,\r\n      eventName,\r\n      event\r\n    ) => {\r\n      if (!handler) {\r\n        return;\r\n      }\r\n\r\n      if (once) {\r\n        Handler.off(element, eventName);\r\n      }\r\n\r\n      if (selector) {\r\n        let target = event.target;\r\n        while (\r\n          target &&\r\n          target !== element &&\r\n          target.matches &&\r\n          !target.matches(selector)\r\n        ) {\r\n          target = target.parentNode;\r\n        }\r\n\r\n        if (target && target.matches && target.matches(selector)) {\r\n          handler.call(target, event);\r\n        }\r\n      } else {\r\n        handler.call(element, event);\r\n      }\r\n    };\r\n\r\n    return {\r\n      on: function(element, event, selector, handler, capture, once) {\r\n        // Store the full namespaced event binding only the type\r\n        const type = event.split(\".\")[0];\r\n        handler = handlerDelegate.bind(\r\n          element,\r\n          selector,\r\n          handler,\r\n          element,\r\n          once,\r\n          event\r\n        );\r\n        element.addEventListener(type, handler, capture);\r\n        getHandlers(element, event, true)[i++] = {\r\n          type: type,\r\n          handler: handler,\r\n          capture: capture\r\n        };\r\n      },\r\n      off: function(element, event) {\r\n        let handlers = getHandlers(element, event, false);\r\n        keys(handlers).forEach(l => {\r\n          let h = handlers[l];\r\n          element.removeEventListener(h.type, h.handler, h.capture);\r\n          delete handlers[l];\r\n        });\r\n      }\r\n    };\r\n  })();\r\n\r\n  /**\r\n   * Specifies helper methods for traversing and manipulating the Document Object Model (DOM)\r\n   * in an efficient manner\r\n   * @class DUM\r\n   */\r\n  class DUM {\r\n    /**\r\n     * Specifies a function to execute when the element of DOM is fully loaded.\r\n     * @param {HTMLElement | HTMLDocument} context The context to monitor the state of; defaults to `document` if not set\r\n     * @returns {Promise}\r\n     * @memberof DUM\r\n     */\r\n    ready(context) {\r\n      context = context || d;\r\n\r\n      // eslint-disable-next-line no-unused-vars\r\n      return new Promise((resolve, reject) => {\r\n        if (context.readyState !== \"loading\") {\r\n          resolve();\r\n        } else {\r\n          Handler.on(\r\n            context,\r\n            \"DOMContentLoaded\",\r\n            null,\r\n            () => resolve(),\r\n            true,\r\n            true\r\n          );\r\n        }\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Returns a reference to the first object with the specified value of the `id` or `name` attribute.\r\n     * @param {string} id\r\n     * @returns {HTMLElement | null}\r\n     * @memberof DUM\r\n     */\r\n    id(id) {\r\n      return d.getElementById(id);\r\n    }\r\n\r\n    /**\r\n     * Returns the first element that is a descendant of the element on which it is invoked that matches the\r\n     * specified group of selectors.\r\n     * @param {string} expression The selector expression; this must be valid CSS syntax\r\n     * @param {HTMLElement | HTMLDocument} context The context to search within; defaults to `document` if not set\r\n     * @returns {HTMLElement | null}\r\n     * @memberof DUM\r\n     */\r\n    query(expression, context) {\r\n      if ((arguments.length == 2 && !context) || !expression) {\r\n        return null;\r\n      }\r\n\r\n      return isString(expression)\r\n        ? (context || d).querySelector(expression)\r\n        : expression || null;\r\n    }\r\n\r\n    /**\r\n     * Returns a list of the elements within the element or collection of elements (using depth-first pre-order traversal of the elements nodes)\r\n     * that match the specified group of selectors. The object returned is different from `querySelectorAll` in that it is a true array.\r\n     * @param {string} expression The selector expression; this must be valid CSS syntax\r\n     * @param {HTMLElement | HTMLElement[] | HTMLDocument} contexts The element or collection of elements to search within; defaults to `document` if not set\r\n     * @returns {HTMLElement[]}\r\n     * @memberof DUM\r\n     */\r\n    queryAll(expression, contexts) {\r\n      if (expression instanceof Node || expression instanceof Window) {\r\n        return [expression];\r\n      }\r\n\r\n      if (isArray(contexts) && !contexts.length) {\r\n        return [];\r\n      }\r\n\r\n      return arrayFunction(contexts || document, function() {\r\n        return toArray(\r\n          isString(expression)\r\n            ? this.querySelectorAll(expression)\r\n            : expression || []\r\n        );\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Returns the element matching the optional expression immediately prior to the specified one in its parent's children list,\r\n     * or `null` if the specified element is the first one in the list.\r\n     * @param {HTMLElement} element The element to search from\r\n     * @param {string} expression The optional selector expression; this must be valid CSS syntax\r\n     * @returns {HTMLElement | null}\r\n     * @memberof DUM\r\n     */\r\n    prev(element, expression) {\r\n      return expression\r\n        ? sibling(element, \"previousElementSibling\", expression)\r\n        : element.previousElementSibling;\r\n    }\r\n\r\n    /**\r\n     * Returns the element matching the optional expression immediately following to the specified one in its parent's children list,\r\n     * or `null` if the specified element is the last one in the list.\r\n     * @param {HTMLElement} element The element to search from\r\n     * @param {string} expression The optional selector expression; this must be valid CSS syntax\r\n     * @returns {HTMLElement | null}\r\n     * @memberof DUM\r\n     */\r\n    next(element, expression) {\r\n      return expression\r\n        ? sibling(element, \"nextElementSibling\", expression)\r\n        : element.nextElementSibling;\r\n    }\r\n\r\n    /**\r\n     * Returns an ordered collection of DOM elements that are children of the given element or element collection.\r\n     * If there are no element children, then children contains no elements and has a length of 0.\r\n     * @param {HTMLElement | HTMLElement[]} elements The element or collection of elements to search within\r\n     * @param {string} expression The optional selector expression; this must be valid CSS syntax\r\n     * @returns {HTMLElement[]}\r\n     * @memberof DUM\r\n     */\r\n    children(elements, expression) {\r\n      return arrayFunction(elements, function() {\r\n        return toArray(this && this.children).filter(c =>\r\n          expression ? c.matches(expression) : true\r\n        );\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Creates an instance of an element for the specified tag\r\n     * @param {string} type\r\n     * @returns {HTMLElement}\r\n     * @memberof DUM\r\n     */\r\n    create(type) {\r\n      return d.createElement(type);\r\n    }\r\n\r\n    /**\r\n     * Creates an instance of an element or elements from the given HTML.\r\n     * @param {string} html\r\n     * @param {string | undefined} selector The optional selector expression; this must be valid CSS syntax or `undefined`\r\n     * @returns {HTMLElement| HTMLElement[]}\r\n     * @memberof DUM\r\n     */\r\n    fromHtml(html, selector) {\r\n      var result = selector\r\n        ? this.queryAll(selector, parseHtml(html))\r\n        : this.children(parseHtml(html).body);\r\n\r\n      return result.length === 1 ? result[0] : result;\r\n    }\r\n\r\n    /**\r\n     * Prepends the child or collection of child elements to the element or collection of elements.\r\n     * The child collection is reversed before prepending to ensure order is correct.\r\n     * If prepending to multiple elements the nodes are deep cloned for successive elements.\r\n     * @param {HTMLElement | HTMLElement[]} elements The element or collection of elements to prepend within\r\n     * @param {HTMLElement | HTMLElement[]} children The child or collection of child elements\r\n     * @memberof DUM\r\n     */\r\n    prepend(elements, children) {\r\n      insertAction(elements, children, true, function(c) {\r\n        this.insertBefore(c, this.firstChild);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Appends the child or collection of child elements to the element or collection of elements\r\n     * If appending to multiple elements the nodes are deep cloned for successive elements.\r\n     * @param {HTMLElement | HTMLElement[]} elements The element or collection of elements to prepend within\r\n     * @param {HTMLElement | HTMLElement[]} children The child or collection of child elements\r\n     * @memberof DUM\r\n     */\r\n    append(elements, children) {\r\n      insertAction(elements, children, false, function(c) {\r\n        this.appendChild(c);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Detaches an element from the DOM returning the result. Any event handlers bound to the element are still present.\r\n     * @param {HTMLElement} element The element to detach\r\n     * @returns {HTMLElement}\r\n     * @memberof DUM\r\n     */\r\n    detach(element) {\r\n      element && element.remove();\r\n      return element;\r\n    }\r\n\r\n    /**\r\n     * Returns a value indicating whether the specified class value exists in class attribute of the element.\r\n     * @param {HTMLElement} element The element to search within\r\n     * @param {string} name The class name\r\n     * @returns {boolean}\r\n     * @memberof DUM\r\n     */\r\n    hasClass(element, name) {\r\n      return element.classList.contains(name);\r\n    }\r\n\r\n    /**\r\n     * Add the specified class, space-separated class values or class array to the given element or collection of elements.\r\n     * If these classes already exist in attribute of the element, then they are ignored.\r\n     * @param {HTMLElement | HTMLElement[]} elements The element or collection of elements\r\n     * @param {string | string[]} names\r\n     * @memberof DUM\r\n     */\r\n    addClass(elements, names) {\r\n      classAction(elements, \"add\", names);\r\n    }\r\n\r\n    /**\r\n     * Removes the specified class, space-separated class values or class array from the given element or collection of elements.\r\n     * If these classes already exist in attribute of the element, then they are ignored.\r\n     * @param {HTMLElement | HTMLElement[]} elements The element or collection of elements\r\n     * @param {string | string[]} names\r\n     * @memberof DUM\r\n     */\r\n    removeClass(elements, names) {\r\n      classAction(elements, \"remove\", names);\r\n    }\r\n\r\n    /**\r\n     * Toggles the specified class, space-separated class values or class array to or from the given element or collection of elements.\r\n     * If these classes already exist in attribute of the element, then they are ignored.\r\n     * @param {HTMLElement | HTMLElement[]} elements The element or collection of elements\r\n     * @param {string | string[]} names\r\n     * @memberof DUM\r\n     */\r\n    toggleClass(elements, names) {\r\n      classAction(elements, \"toggle\", names);\r\n    }\r\n\r\n    /**\r\n     * Returns the value of a specified attribute on the element. If the given attribute does not exists the value\r\n     * returned will be `null`.\r\n     * @param {HTMLElement} element The element\r\n     * @param {string} name The string specifying the attribute whose value to return\r\n     * @returns {HTMLElement | null}\r\n     * @memberof DUM\r\n     */\r\n    getAttr(element, name) {\r\n      return element && element.getAttribute(name);\r\n    }\r\n\r\n    /**\r\n     * Sets the collection of attribute values on the element or collection of elements.\r\n     * @param {HTMLElement | HTMLElement[]} elements The element or collection of elements\r\n     * @param {object} values The object contining the collection of key-value attribute pairs to set\r\n     * @memberof DUM\r\n     */\r\n    setAttr(elements, values) {\r\n      arrayFunction(elements, function() {\r\n        keys(values).forEach(k => this.setAttribute(k, values[k]));\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Removes specified attribute, space-separated attribute names or attribute array from the element or collection of elements.\r\n     * @param {HTMLElement | HTMLElement[]} elements The element or collection of elements\r\n     * @param {string | string[]} names The name or array of names to remove\r\n     * @memberof DUM\r\n     */\r\n    removeAttr(elements, names) {\r\n      (isArray(names) ? names : names.split(rspace)).forEach(n => {\r\n        arrayFunction(elements, function() {\r\n          this.removeAttribute(n);\r\n        });\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Sets the collection of style values on the element or collection of elements.\r\n     * @param {HTMLElement | HTMLElement[]} elements The element or collection of elements\r\n     * @param {object} values The object contining the collection of key-value attribute pairs to set\r\n     * @memberof DUM\r\n     */\r\n    setStyle(elements, values) {\r\n      arrayFunction(elements, function() {\r\n        keys(values).forEach(k => {\r\n          if (k in this.style) {\r\n            this.style[k] = values[k];\r\n          } else {\r\n            this.style.setProperty(k, values[k]);\r\n          }\r\n        });\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Empties the contents of the given element or collection of elements.\r\n     * Any event handlers bound to the element contents are automatically garbage collected.\r\n     * @param {HTMLElement | HTMLElement[]} elements The element or collection of elements\r\n     * @memberof DUM\r\n     */\r\n    empty(elements) {\r\n      arrayFunction(elements, function() {\r\n        let child = this;\r\n        while ((child = this.firstChild)) {\r\n          child.remove(); // Events are automatically garbage collected\r\n        }\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Adds an event listener to the given element or collection of elements. Events can be delegated to a parent by passing a CSS selector.\r\n     * @param {HTMLElement | HTMLElement[]} elements The element or collection of elements\r\n     * @param {string | string[]} events The event or collection of event names\r\n     * @param {string | undefined} selector The optional selector expression; this must be valid CSS syntax or `undefined`\r\n     * @param {Function} handler The function to call when the event is triggered\r\n     * @memberof DUM\r\n     */\r\n    on(elements, events, selector, handler) {\r\n      doBind(false, elements, events, selector, handler);\r\n    }\r\n\r\n    /**\r\n     * Adds an event listener to the given element or collection of elements that is immediately unbound when the event is triggered.\r\n     * Events can be delegated to a parent by passing a CSS selector.\r\n     * @param {HTMLElement | HTMLElement[]} elements The element or collection of elements\r\n     * @param {string | string[]} events The event or collection of event names\r\n     * @param {string | undefined} selector The selector expression; this must be valid CSS syntax or `undefined`\r\n     * @param {Function} handler The function to call when the event is triggered\r\n     * @memberof DUM\r\n     */\r\n    one(elements, events, selector, handler) {\r\n      doBind(true, elements, events, selector, handler);\r\n    }\r\n\r\n    /**\r\n     * Removes any event listener matching the given name or names.\r\n     * @param {HTMLElement | HTMLElement[]} elements The element or collection of elements\r\n     * @param {string | string[]} events The event name or names, previously bound using `on`.\r\n     * @memberof DUM\r\n     */\r\n    off(elements, events) {\r\n      arrayFunction(elements, function() {\r\n        let el = this;\r\n        arrayFunction(events, function() {\r\n          Handler.off(el, this);\r\n        });\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Triggers an event returning a value indicating whether the event has been cancelled.\r\n     * By default the event bubbles and is cancelable.\r\n     * @param {HTMLElement | HTMLElement[]} elements The element or collection of elements\r\n     * @param {string} event The name of the event to trigger\r\n     * @param {object} detail Optional and defaulting to `null` this contains any event dependant value associated with the event\r\n     * @returns {boolean} A value indicating whether at least one of the bound event handlers called `Event.preventDefault()`\r\n     * @memberof DUM\r\n     */\r\n    trigger(elements, event, detail) {\r\n      const namespaces = rtypenamespace.exec(event) || [];\r\n      detail = detail || {};\r\n      detail.namespace = namespaces[2] || \"\";\r\n      const params = { bubbles: true, cancelable: true, detail: detail };\r\n      return (\r\n        arrayFunction(elements, function() {\r\n          return this.dispatchEvent(new CustomEvent(namespaces[1], params));\r\n        }).length || false\r\n      );\r\n    }\r\n  }\r\n\r\n  return (w.$d = w.DUM = new DUM());\r\n})(window, document);\r\n\r\nexport default $d;\r\n","import $d from \"./dum\"\r\nimport RbpBase from \"./base\"\r\nimport RbpCore from \"./core\"\r\n\r\nconst RbpModal = (($d, core, base, w, d) => {\r\n\r\n    const protocol = w.location.protocol.indexOf(\"http\") === 0 ? w.location.protocol : \"http:\";\r\n\r\n    // Regular expressions.\r\n    const rhint = /\\((\\w+)\\|(\\w+)\\)/;\r\n    const rexternalHost = new RegExp(\"//\" + w.location.host + \"($|/)\");\r\n    // Taken from jQuery.\r\n    const rhash = /^#.*$/; // Altered to only match beginning.\r\n    const rurl = /^([\\w.+-]+:)(?:\\/\\/([^/?#:]*)(?::(\\d+)|)|)/;\r\n    const rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/;\r\n    const rimage = /(^data:image\\/.*,)|(\\.(jp(e|g|eg)|gif|png|bmp|ti(ff|f)|webp|svg)((\\?|#).*)?$)/i;\r\n\r\n    const fromTemplate = (template) => {\r\n        return core.parseHtml(template).body.firstChild;\r\n    }\r\n\r\n    const getMediaProvider = url => {\r\n        const providers = {\r\n            youtube: /youtu(be\\.com|be\\.googleapis\\.com|\\.be)/i,\r\n            vimeo: /vimeo/i,\r\n            vine: /vine/i,\r\n            instagram: /instagram|instagr\\.am/i,\r\n            getty: /embed\\.gettyimages\\.com/i\r\n        };\r\n\r\n        const keys = Object.keys(providers);\r\n        for (let i = 0; i < keys.length; i++) {\r\n            let k = keys[i];\r\n            let p = providers[k];\r\n            if (p.test(url)) {\r\n                return k;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    const isExternalUrl = url => {\r\n\r\n        // Handle different host types.\r\n        // Split the url into it's various parts.\r\n        const locationParts = rurl.exec(url) || rurl.exec(protocol + url);\r\n\r\n        if (locationParts === undefined || rhash.test(url)) {\r\n            return false;\r\n        }\r\n\r\n        // Target is a local protocol.\r\n        if (!locationParts || !locationParts[2] || rlocalProtocol.test(locationParts[1])) {\r\n            return false;\r\n        }\r\n\r\n        // If the regex doesn't match return true . \r\n        return !rexternalHost.test(locationParts[2]);\r\n    };\r\n\r\n    // Context is bound to the modal instance\r\n    function buildMain(complete) {\r\n        const notHash = !rhash.test(this.target),\r\n            external = isExternalUrl(this.target),\r\n            iframeScroll = this.options.iframeScroll === true,\r\n            isImage = this.options.image === true || rimage.test(this.target),\r\n            isIframe = this.options.iframe === true || notHash && external ? !isImage : false;\r\n\r\n        this.local = !notHash && !external;\r\n\r\n        if (!this.local) {\r\n            // iframe\r\n            if (isIframe) {\r\n                if (iframeScroll) {\r\n                    // Prevent double scroll\r\n                    $d.addClass(this.main, \"no-overflow\");\r\n                }\r\n\r\n                const src = (external && this.target.indexOf(\"http\") !== 0) ? protocol + this.target : this.target;\r\n                const frame = $d.create(\"iframe\");\r\n                $d.setAttr(frame, {\r\n                    \"scrolling\": iframeScroll ? \"yes\" : \"no\",\r\n                    \"allowTransparency\": true,\r\n                    \"allowfullscreen\": \"\"\r\n                });\r\n\r\n                // Test and add media wrapper + classes.\r\n                const mediaClass = getMediaProvider(this.target);\r\n                if (mediaClass) {\r\n                    const iframeWrap = $d.create(\"div\");\r\n                    $d.addClass(iframeWrap, [\"media\", mediaClass]);\r\n                    $d.append(iframeWrap, frame);\r\n                    $d.append(this.main, iframeWrap);\r\n\r\n                    // Undo full height to allow aspect-ratio\r\n                    $d.addClass(this.modal, \"auto-height\");\r\n                } else {\r\n                    $d.append(this.main, frame);\r\n                }\r\n\r\n                // Ensure callback is called only once fully loaded\r\n                $d.one(frame, [\"load\", \"error\"], null, complete);\r\n                $d.setAttr(frame, { \"src\": src });\r\n                return;\r\n            }\r\n\r\n            // image\r\n            if (isImage) {\r\n                $d.addClass(this.modal, \"auto-height auto-width\");\r\n                const image = $d.create(\"img\");\r\n                $d.append(this.main, image);\r\n\r\n                // Ensure callback is called only once fully loaded\r\n                $d.one(image, [\"load\", \"error\"], null, complete);\r\n                $d.setAttr(image, { \"src\": this.target });\r\n                return;\r\n            }\r\n\r\n            // html\r\n            core.loadHtml(this.target).then(html => {\r\n                html = html.outerHTML;\r\n                this.main.innerHTML = html;\r\n                complete();\r\n            }).catch(complete);\r\n        }\r\n        // TODO: Local swap out\r\n    }\r\n\r\n    // Context is bound to the modal instance\r\n    function destroyMain() {\r\n\r\n        $d.removeClass(this.main, \"no-overflow\");\r\n        if (!this.local) {\r\n            $d.empty(this.main);\r\n        }\r\n\r\n        // TODO Handle local\r\n    }\r\n\r\n    const defaults = {\r\n        modal: null,\r\n        external: false,\r\n        group: null,\r\n        image: false,\r\n        immediate: false,\r\n        iframe: false,\r\n        iframeScroll: true,\r\n        keyboard: true,\r\n        touch: true,\r\n        nextHint: \"Next: (Left|Right) Arrow\",\r\n        prevHint: \"Previous: (Right|Left) Arrow\",\r\n        closeHint: \"Close (Esc)\",\r\n        errorHint: \"<p>An error has occured.</p>\",\r\n        loadHint: \"Loading modal content\",\r\n        mobileTarget: null,\r\n        mobileViewportWidth: \"xs\",\r\n        fitViewport: true,\r\n        title: null,\r\n        description: null\r\n    };\r\n\r\n    class RbpModal extends base {\r\n\r\n        constructor(element, options) {\r\n            super(element, defaults, options, \"modal\");\r\n\r\n            // We fallback to the attribute to preserve relative urls\r\n            this.target = this.options.target || $d.getAttr(this.element, \"href\");\r\n            if (!this.target) {\r\n                return;\r\n            }\r\n\r\n            this.title = null;\r\n            this.description = null;\r\n\r\n            this.isShown = null;\r\n            this.group = $d.queryAll(this.options.group) || [];\r\n            this.groupIndex = 0;\r\n            this.nextHint = this.options.nextHint.replace(rhint, this.rtl ? \"$1\" : \"$2\");\r\n            this.prevHint = this.options.prevHint.replace(rhint, this.rtl ? \"$1\" : \"$2\");\r\n\r\n            const modalId = core.uid();\r\n            this.overlay = fromTemplate(`<div role=\"document\" class=\"modal-overlay fade-out\"></div>`);\r\n            this.dummy = $d.id(\"dmo\");\r\n            if (!this.dummy) {\r\n                this.dummy = fromTemplate(`<div id=\"dmo\" hidden class=\"fade-out\"></div>`);\r\n                $d.prepend(d.body, this.dummy);\r\n            }\r\n\r\n            this.modal = fromTemplate(`<div id=\"${modalId}\" class=\"modal fade-out\"></div>`);\r\n            this.loader = fromTemplate(`<span class=\"modal-loader\"><span class=\"vhidden\">${this.options.loadHint}</span></span>`);\r\n            this.closeTrigger = fromTemplate(`<button class=\"modal-close\"><span class=\"vhidden\">${this.closeHint}</span></button>`);\r\n            this.prevTrigger = fromTemplate(`<button><span class=\"vhidden\">${this.prevHint}</span></button>`);\r\n            this.nextTrigger = fromTemplate(`<button class=\"forward\"><span class=\"vhidden\">${this.nextHint}</span></button>`);\r\n\r\n            if (this.options.title) {\r\n                this.titleId = core.uid();\r\n                this.header = fromTemplate(`<header><h2 id=\"${this.titleId}\">${this.options.title}</h2></header>`);\r\n            }\r\n\r\n            this.main = $d.create(\"main\");\r\n\r\n            if (this.options.description) {\r\n                this.descId = core.uid();\r\n                this.footer = fromTemplate(`<footer><p id=\"${this.descId}\">${this.options.description}</p></footer>`);\r\n            }\r\n\r\n            // A11y\r\n            $d.setAttr([this.prevTrigger, this.nextTrigger], { \"tabindex\": 0, \"aria-controls\": modalId });\r\n            if (this.titleId || this.descId) {\r\n\r\n                $d.setAttr(this.overlay, { \"aria-labelledby\": `${this.titleId || \"\"} ${this.descId || \"\"}` });\r\n            }\r\n\r\n            // Bind events.\r\n            $d.on(this.element, \"click\", null, this.click.bind(this));\r\n            $d.on(this.overlay, \"click\", null, this.overlayClick.bind(this));\r\n\r\n            if (this.options.immediate) {\r\n                this.show();\r\n            }\r\n        }\r\n\r\n        click(event) {\r\n            event.preventDefault();\r\n            this.show();\r\n        }\r\n\r\n        overlayClick(event) {\r\n            if (this.options.modal) {\r\n                return;\r\n            }\r\n\r\n            const eventTarget = event.target;\r\n\r\n            // Order is important here. We always have to check the modal first\r\n            if (eventTarget === this.modal || this.modal.contains(eventTarget)) {\r\n                return;\r\n            }\r\n\r\n            if (eventTarget === this.closeTrigger) {\r\n                this.hideModal();\r\n                return;\r\n            }\r\n\r\n            if (eventTarget === this.overlay || this.overlay.contains(eventTarget)) {\r\n                this.hideModal();\r\n            }\r\n        }\r\n\r\n        show() {\r\n            if (this.isShown) { return; }\r\n\r\n            const complete = () => {\r\n                $d.setAttr(this.dummy, { \"hidden\": \"\" });\r\n                // TODO: track scroll position\r\n                this.showModal();\r\n            };\r\n\r\n            $d.append(this.overlay, this.loader);\r\n            $d.append(d.body, this.overlay);\r\n            core.redraw(this.overlay);\r\n\r\n            core.onTransitionEnd(this.overlay, complete);\r\n\r\n            core.redraw(this.dummy);\r\n            $d.removeClass(this.dummy, \"fade-in\");\r\n            $d.addClass(this.overlay, \"fade-in\");\r\n        }\r\n\r\n        showModal() {\r\n\r\n            if (this.isShown) { return; }\r\n\r\n            const complete = () => {\r\n                this.isShown = true;\r\n            };\r\n\r\n            $d.append(this.overlay, this.modal);\r\n            if (this.header) {\r\n                $d.append(this.modal, this.header);\r\n            }\r\n\r\n            $d.append(this.modal, this.main);\r\n\r\n            if (this.footer) {\r\n                $d.append(this.modal, this.footer);\r\n            }\r\n            const animate = () => {\r\n                this.loader = $d.detach(this.loader);\r\n\r\n                core.redraw(this.modal);\r\n                core.onTransitionEnd(this.modal, complete);\r\n                $d.addClass(this.modal, \"fade-in\");\r\n            }\r\n\r\n            // Lazy load main content\r\n            buildMain.call(this, animate);\r\n        }\r\n\r\n        hide() {\r\n            if (!this.isShown) { return; }\r\n\r\n            const complete = () => {\r\n                // TODO: Fire events\r\n                this.isShown = false;\r\n                this.overlay = $d.detach(this.overlay);\r\n            };\r\n\r\n            core.redraw(this.overlay);\r\n            core.onTransitionEnd(this.overlay, complete);\r\n\r\n            $d.removeClass(this.overlay, \"fade-in\");\r\n        }\r\n\r\n        hideModal() {\r\n\r\n            if (!this.isShown) { return; }\r\n\r\n            const complete = () => {\r\n                $d.removeClass(this.modal, \"auto-height auto-width\");\r\n\r\n                // TODO: Fire events\r\n                this.header = $d.detach(this.header);\r\n\r\n                destroyMain.call(this);\r\n                this.main = $d.detach(this.main);\r\n\r\n                this.footer = $d.detach(this.footer);\r\n\r\n                w.requestAnimationFrame(() => {\r\n                    $d.removeAttr(this.dummy, \"hidden\");\r\n                    core.redraw(this.dummy);\r\n\r\n                    $d.addClass(this.dummy, \"fade-in\");\r\n                    core.redraw(this.dummy);\r\n                    this.hide();\r\n                });\r\n            };\r\n\r\n            core.redraw(this.modal);\r\n            core.onTransitionEnd(this.modal, complete);\r\n            $d.removeClass(this.modal, \"fade-in\");\r\n        }\r\n    }\r\n\r\n    // Register plugin and data-api event handler and return\r\n    return core.registerDataApi(RbpModal, \"modal\", defaults);\r\n\r\n})($d, RbpCore, RbpBase, window, document);\r\n\r\nexport default RbpModal;","import $d from \"./dum\"\r\n\r\nconst Swiper = (($d, w) => {\r\n\r\n    const support = {\r\n        touchEvents: \"ontouchstart\" in w || w.DocumentTouch && document instanceof w.DocumentTouch,\r\n        pointerEvents: w.PointerEvent\r\n    };\r\n\r\n    const pointerStart = \"pointerdown\",\r\n        pointerMove = \"pointermove\",\r\n        pointerEnd = [\"pointerup\", \"pointerout\", \"pointercancel\", \"pointerleave\", \"lostpointercapture\"];\r\n\r\n    const touchStart = \"touchstart\",\r\n        touchMove = \"touchmove\",\r\n        touchEnd = [\"touchend\", \"touchleave\", \"touchcancel\"];\r\n\r\n    const mouseStart = \"mousedown\",\r\n        mouseMove = \"mousemove\",\r\n        mouseEnd = [\"mouseup\", \"mouseleave\"];\r\n\r\n    const getTouchEvents = () => {\r\n        let eend = mouseEnd,\r\n            emove = mouseMove,\r\n            estart = mouseStart;\r\n\r\n        // Keep the events separate since support could be crazy.\r\n        if (support.touchEvents) {\r\n            estart = touchStart;\r\n            emove = touchMove;\r\n            eend = touchEnd;\r\n        } else if (support.pointerEvents) {\r\n            estart = pointerStart;\r\n            emove = pointerMove;\r\n            eend = pointerEnd;\r\n        }\r\n\r\n        return {\r\n            start: estart,\r\n            move: emove,\r\n            end: eend\r\n        };\r\n    };\r\n\r\n    const getSwipeEvents = ns => ({\r\n        swipeStart: `swipestart${ns}`,\r\n        swipeMove: `swipemove${ns}`,\r\n        swipeEnd: `swipeend${ns}`\r\n    });\r\n\r\n    const bindTouchEvents = swiper => {\r\n\r\n        // Enable extended touch events on supported browsers before any touch events.\r\n        if (support.pointerEvents) {\r\n            swiper.elements.forEach(e => {\r\n                $d.setStyle(e, { touchAction: swiper.touchAction });\r\n            });\r\n        }\r\n\r\n        swiper.elements.forEach(element => {\r\n\r\n            let delta = {},\r\n                start = {};\r\n\r\n            const onMove = event => {\r\n\r\n                // Normalize the variables.\r\n                let isMouse = event.type === \"mousemove\",\r\n                    isPointer = event.type !== \"touchmove\" && !isMouse;\r\n\r\n                // Only left click allowed.\r\n                if (isMouse && event.which !== 1) {\r\n                    return;\r\n                }\r\n\r\n                // One touch allowed.\r\n                if (event.touches && event.touches.length > 1) {\r\n                    return;\r\n                }\r\n\r\n                // Ensure swiping with one touch and not pinching.\r\n                if (event.scale && event.scale !== 1) {\r\n                    return;\r\n                }\r\n\r\n                /* eslint-disable no-nested-ternary */\r\n                const dx = (isMouse ? event.pageX : isPointer ? event.clientX : event.touches[0].pageX) - start.x;\r\n                const dy = (isMouse ? event.pageY : isPointer ? event.clientY : event.touches[0].pageY) - start.y;\r\n                /* eslint-enable no-nested-ternary */\r\n\r\n                /* eslint-disable sort-vars, no-extra-parens */\r\n                let doSwipe = false,\r\n                    rectangle = element.getBoundingClientRect(),\r\n                    percentX = Math.abs(parseFloat((dx / rectangle.width) * 100)) || 100,\r\n                    percentY = Math.abs(parseFloat((dy / rectangle.height) * 100)) || 100;\r\n                /* eslint-enable sort-vars, no-extra-parens */\r\n\r\n                // Work out whether to do a scroll based on the sensitivity limit.\r\n                switch (swiper.touchAction) {\r\n                    case \"pan-x\":\r\n                        if (Math.abs(dy) > Math.abs(dx)) {\r\n                            event.preventDefault();\r\n                        }\r\n                        doSwipe = Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > swiper.sensitivity && percentY < 100;\r\n                        break;\r\n                    case \"pan-y\":\r\n                        if (Math.abs(dx) > Math.abs(dy)) {\r\n                            event.preventDefault();\r\n                        }\r\n                        doSwipe = Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > swiper.sensitivity && percentX < 100;\r\n                        break;\r\n                    default:\r\n                        event.preventDefault();\r\n                        doSwipe = Math.abs(dy) > swiper.sensitivity || Math.abs(dx) > swiper.sensitivity && percentX < 100 && percentY < 100;\r\n                        break;\r\n                }\r\n\r\n                event.stopPropagation();\r\n                if (!doSwipe || !$d.trigger(element, swiper.swipeEvents.swipeMove, { delta: { x: dx, y: dy } })) {\r\n                    return;\r\n                }\r\n\r\n                // Measure change in x and y.\r\n                delta = {\r\n                    x: dx,\r\n                    y: dy\r\n                };\r\n            };\r\n\r\n            const onEnd = () => {\r\n                // Measure duration\r\n                const duration = Number(new Date()) - start.time;\r\n\r\n                // Determine if slide attempt triggers slide.\r\n                if (Math.abs(delta.x) > 1 || Math.abs(delta.y) > 1) {\r\n\r\n                    // Set the direction and return it.\r\n                    /* eslint-disable sort-vars */\r\n                    const horizontal = delta.x < 0 ? \"left\" : \"right\",\r\n                        vertical = delta.y < 0 ? \"up\" : \"down\",\r\n                        direction = Math.abs(delta.x) > Math.abs(delta.y) ? horizontal : vertical;\r\n                    /* eslint-disable sort-vars */\r\n\r\n                    if (!$d.trigger(element, swiper.swipeEvents.swipeEnd, { delta: delta, direction: direction, duration: duration })) {\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                // Disable the touch events till next time.\r\n                $d.off(element, swiper.touchEvents.move);\r\n                $d.off(element, swiper.touchEvents.end);\r\n            };\r\n\r\n            const onStart = event => {\r\n                // Normalize the variables.\r\n                const isMouse = event.type === \"mousedown\";\r\n                const isPointer = event.type !== \"touchstart\" && !isMouse;\r\n\r\n                event.stopPropagation();\r\n\r\n                // Measure start values.\r\n                start = {\r\n                    // Get initial touch coordinates.\r\n                    /* eslint-disable no-nested-ternary */\r\n                    x: isMouse ? event.pageX : isPointer ? event.clientX : event.touches[0].pageX,\r\n                    y: isMouse ? event.pageY : isPointer ? event.clientY : event.touches[0].pageY,\r\n                    /* eslint-enable no-nested-ternary */\r\n\r\n                    // Store time to determine touch duration.\r\n                    time: Number(new Date())\r\n                };\r\n\r\n                if (!$d.trigger(element, swiper.swipeEvents.swipeStart, { start: start })) {\r\n                    return;\r\n                }\r\n\r\n                // Reset delta and end measurements.\r\n                delta = { x: 0, y: 0 };\r\n\r\n                // Attach touchmove and touchend listeners.\r\n                $d.on(element, swiper.touchEvents.move, null, onMove);\r\n                $d.on(element, swiper.touchEvents.end, null, onEnd);\r\n            };\r\n\r\n            $d.off(element, swiper.touchEvents.start);\r\n            $d.on(element, swiper.touchEvents.start, null, onStart);\r\n        });\r\n    };\r\n\r\n    class Swiper {\r\n        constructor(selector, namespace, touchAction, sensitivity) {\r\n            this.selector = selector;\r\n            this.namespace = namespace ? `.${namespace}` : \"\";\r\n            this.touchAction = touchAction || \"none\";\r\n            this.sensitivity = sensitivity || 5;\r\n            this.swipeEvents = getSwipeEvents(this.namespace);\r\n            this.touchEvents = getTouchEvents();\r\n            this.elements = $d.queryAll(selector);\r\n            bindTouchEvents(this);\r\n        }\r\n\r\n        onSwipeStart(element, handler) {\r\n            $d.on(this.elements, this.swipeEvents.swipeStart, null, handler);\r\n            return this;\r\n        }\r\n\r\n        onSwipeMove(handler) {\r\n            $d.on(this.elements, this.swipeEvents.swipeMove, null, handler);\r\n            return this;\r\n        }\r\n\r\n        onSwipeEnd(handler) {\r\n            $d.on(this.elements, this.swipeEvents.swipeEnd, null, handler);\r\n            return this;\r\n        }\r\n\r\n        destroy() {\r\n            $d.off(this.elements, this.swipeEvents.swipeStart);\r\n            $d.off(this.elements, this.swipeEvents.swipeMove);\r\n            $d.off(this.elements, this.swipeEvents.swipeEnd);\r\n        }\r\n    }\r\n\r\n    return Swiper;\r\n\r\n})($d, window);\r\n\r\nexport default Swiper","import $d from \"./dum\"\r\nimport RbpBase from \"./base\"\r\nimport RbpCore from \"./core\"\r\n\r\nconst RbpTableList = (($d, core, base) => {\r\n\r\n    const defaults = {};\r\n    class RbpTableList extends base {\r\n\r\n        constructor(element, options) {\r\n            super(element, defaults, options, \"tablelist\");\r\n\r\n            this.eadd = \"add.rbp\";\r\n            this.eadded = \"added.rbp\";\r\n            this.isAdded = false;\r\n\r\n            $d.addClass(this.element, \"table-list\");\r\n            $d.setAttr(this.element, { \"aria-role\": \"grid\" });\r\n\r\n            this.thead = $d.children(this.element, \"thead\");\r\n            this.tfoot = $d.children(this.element, \"tfoot\");\r\n            this.tbody = $d.children(this.element, \"tbody\");\r\n            this.hasHeader = this.thead.length;\r\n\r\n            this.headerColumns = $d.queryAll(\"th\", this.thead);\r\n            this.footerColumns = $d.queryAll(\"th\", this.tfoot);\r\n            this.footerColumns.forEach(f => $d.setAttr(f, { \"aria-role\": \"columnheader\", \"aria-hidden\": \"false\" }));\r\n            this.bodyRows = $d.children(this.tbody, \"tr\");\r\n            $d.setAttr(this.bodyRows, { \"aria-role\": \"row\" });\r\n\r\n            if (!this.headerColumns.length) {\r\n                this.hasHeader = false;\r\n                $d.addClass(this.element, \"no-thead\");\r\n                this.headerColumns = $d.children(this.bodyRows, \"[scope=row]\");\r\n            }\r\n            this.headerColumns.forEach(h => $d.setAttr(h, { \"aria-role\": \"columnheader\", \"aria-hidden\": \"false\" }));\r\n\r\n            this.add();\r\n        }\r\n\r\n        add() {\r\n\r\n            if (this.isAdded || !$d.trigger(this.element, this.eadd)) {\r\n                return;\r\n            }\r\n\r\n            this.isAdded = true;\r\n            this.bodyRows.forEach(r => {\r\n                let selector = this.hasHeader ? \"th, td\" : \"td\";\r\n                $d.queryAll(selector, r).forEach((t, i) => {\r\n\r\n                    let headerColumn = selector === \"td\" ? $d.prev(t, \"[scope=row]\") : this.headerColumns[i],\r\n                        headerId = headerColumn.id || (headerColumn.id = core.uid()),\r\n                        theadAttribute = headerColumn.innerText;\r\n\r\n                    $d.setAttr(t, { \"data-thead\": theadAttribute, \"aria-role\": \"gridcell\", \"aria-describedby\": headerId });\r\n\r\n                    if (this.tfoot.length) {\r\n                        let footerColumn = this.footerColumns[i],\r\n                            footerId = footerColumn.id || (footerColumn.id = core.uid()),\r\n                            tfootAttribute = footerColumn.innerText;\r\n\r\n                        $d.setAttr(t, { \"data-tfoot\": tfootAttribute, \"aria-role\": \"gridcell\", \"aria-describedby\": footerId });\r\n                    }\r\n                });\r\n            });\r\n\r\n            const complete = () => { $d.trigger(this.element, this.eadded); };\r\n\r\n            core.onTransitionEnd(this.element, complete);\r\n            core.redraw(this.element);\r\n            $d.addClass(this.element, \"fade-in\");\r\n        }\r\n    }\r\n\r\n    // Register plugin and data-api event handler and return\r\n    return core.registerDataApi(RbpTableList, \"tablelist\", null);\r\n\r\n})($d, RbpCore, RbpBase);\r\n\r\nexport default RbpTableList;","import $d from \"./dum\"\r\nimport RbpBase from \"./base\"\r\nimport RbpCore from \"./core\"\r\n\r\nconst RbpTabs = (($d, core, base) => {\r\n\r\n    const defaults = {};\r\n    class RbpTabs extends base {\r\n\r\n        constructor(element, options) {\r\n            super(element, defaults, options, \"tabs\");\r\n\r\n            this.eshow = \"show.rbp\";\r\n            this.eshown = \"shown.rbp\";\r\n\r\n            this.tabbing = false;\r\n\r\n            this.tablist = $d.children(this.element, \"ul\")[0];\r\n            this.tabpanes = $d.children(this.element, \":not(ul)\");\r\n            this.triggers = $d.children(this.tablist);\r\n\r\n            // A11y.\r\n            let id = core.uid(),\r\n                activeIndex = this.triggers.findIndex(l => $d.query(\"[aria-selected=true]\", l)),\r\n                hasActive = activeIndex > -1;\r\n\r\n            $d.setAttr(this.tablist, { \"role\": \"tablist\" });\r\n            this.triggers.forEach((t, i) => {\r\n\r\n                $d.setAttr(t, { \"role\": \"presentation\" });\r\n\r\n                let tab = $d.query(\"a\", t),\r\n                    isActive = (hasActive && i === activeIndex) || (!hasActive && i === 0);\r\n\r\n                $d.setAttr(tab, {\r\n                    \"role\": \"tab\",\r\n                    \"id\": `${id}-${i}`,\r\n                    \"aria-controls\": `${id}-${i}`,\r\n                    \"aria-selected\": isActive ? true : false,\r\n                    \"tabindex\": 0\r\n                });\r\n\r\n                $d.setAttr(this.tabpanes[i], {\r\n                    \"role\": \"tabpanel\",\r\n                    \"id\": `${id}-${i}`,\r\n                    \"aria-labelledby\": `${id}-${i}`,\r\n                    \"tabindex\": isActive ? 0 : -1\r\n                });\r\n            });\r\n\r\n            const selector = \"ul[role=tablist] > li > [role=tab]\";\r\n            $d.on(this.element, \"click\", selector, this.click.bind(this));\r\n            $d.on(this.element, \"keydown\", selector, this.keydown.bind(this));\r\n        }\r\n\r\n        show(position) {\r\n\r\n            let activePosition = this.triggers.findIndex(l => $d.query(\"[aria-selected=true]\", l));\r\n            if (position > (this.triggers.length - 1) || position < 0) {\r\n\r\n                return false;\r\n            }\r\n\r\n            if (activePosition === position) {\r\n                return false;\r\n            }\r\n\r\n            this.tab(activePosition, position);\r\n        }\r\n\r\n        tab(activePosition, postion) {\r\n\r\n            if (this.tabbing || !$d.trigger(this.element, this.eShow)) {\r\n                return;\r\n            }\r\n\r\n            this.tabbing = true;\r\n\r\n            let nextTab = this.triggers[postion],\r\n                currentPane = this.tabpanes[activePosition],\r\n                nextPane = this.tabpanes[postion];\r\n\r\n            $d.setAttr($d.children(this.triggers, \"a\"), { \"aria-selected\": false });\r\n            $d.children(nextTab, \"a\").forEach(a => {\r\n                $d.setAttr(a, { \"aria-selected\": true }); a.focus();\r\n            });\r\n\r\n            // Do some class shuffling to allow the transition.\r\n            $d.addClass(currentPane, \"fade-out fade-in\");\r\n            $d.setAttr(nextPane, { \"tabIndex\": 0 })\r\n            $d.addClass(nextPane, \"fade-out\");\r\n\r\n            // Shouldn't this be simply currentPane?\r\n            let inPanes = this.tabpanes.filter(p => $d.hasClass(p, \"fade-in\"));\r\n\r\n            $d.setAttr(inPanes, { \"tabIndex\": -1 })\r\n            $d.removeClass(inPanes, \"fade-in\");\r\n\r\n            const complete = () => {\r\n                this.tabbing = false;\r\n                $d.removeClass(this.tabpanes, \"fade-out fade-in\");\r\n                $d.trigger(this.element, this.eshown, { relatedTarget: nextPane })\r\n            };\r\n\r\n            core.onTransitionEnd(nextPane, complete);\r\n            core.redraw(nextPane)\r\n            $d.addClass(nextPane, \"fade-in\");\r\n        }\r\n\r\n        click(event) {\r\n\r\n            event.preventDefault();\r\n            event.stopPropagation();\r\n\r\n            this.show(this.triggers.findIndex(l => $d.query(\"a\", l).id === event.target.id));\r\n        }\r\n\r\n        keydown(event) {\r\n\r\n            let which = event.which;\r\n\r\n            // Ignore anything but left and right.\r\n            if (which === core.keys.SPACE || which === core.keys.LEFT || which === core.keys.RIGHT) {\r\n\r\n                event.preventDefault();\r\n                event.stopPropagation();\r\n\r\n                let length = this.triggers.length,\r\n                    index = this.triggers.findIndex(l => $d.query(\"a\", l).id === event.target.id);\r\n\r\n                if (which === core.keys.SPACE) {\r\n                    this.show(index);\r\n                    return;\r\n                }\r\n\r\n                // Select the correct index.\r\n                index = which === core.keys.LEFT ? (this.rtl ? index + 1 : index - 1) : (this.rtl ? index - 1 : index + 1);\r\n\r\n                // Ensure that the index stays within bounds.\r\n                if (index === length) {\r\n                    index = 0;\r\n                }\r\n\r\n                if (index < 0) {\r\n                    index = length - 1;\r\n                }\r\n\r\n                this.show(index);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Register plugin and data-api event handler and return\r\n    return core.registerDataApi(RbpTabs, \"tabs\", null);\r\n\r\n})($d, RbpCore, RbpBase);\r\n\r\nexport default RbpTabs;","// extracted by mini-css-extract-plugin"],"sourceRoot":""}